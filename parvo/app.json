[{"name":"server.R","content":"\n### DEFINE THE SERVER LOGIC ==================================\n\nserver <- function(input, output, session) {\n  \n  ## Server code related to stage_info table ========================\n  \n  # Reactive expression to create default stage_info df\n  initial_stage_info_data <- reactive({\n    if (input$modality == \"Cycle Ergometer\") {\n      data.frame(\n        Stage = paste0(\"Stage_\", 1:5),\n        Cadence = 90,\n        Lactate = as.numeric(NA),\n        RPE = as.numeric(NA)\n      )\n    } else if (input$modality == \"Rowing Ergometer\") {\n      data.frame(\n        Stage = paste0(\"Stage_\", 1:5),\n        Stroke_Rate = 30,\n        Lactate = as.numeric(NA),\n        RPE = as.numeric(NA)\n      )\n    } else {\n      data.frame(\n        Stage = paste0(\"Stage_\", 1:5),\n        Grade = 1,\n        Lactate = as.numeric(NA),\n        RPE = as.numeric(NA)\n      )\n    }\n  })\n  \n  # Reactive values to hold the table data\n  written_info <- reactiveVal()\n  observe({\n    written_info(initial_stage_info_data())\n  })\n  \n  # Observe changes in stage_counter and modality to update the table\n  observe({\n    current_rows <- nrow(written_info())\n    if (input$stage_counter > current_rows) {\n      additional_rows <-\n        if (input$modality == \"Cycle Ergometer\") {\n          data.frame(\n            Stage = paste0(\"Stage_\", (current_rows + 1):input$stage_counter),\n            Cadence = 90,\n            Lactate = as.numeric(NA),\n            RPE = as.numeric(NA)\n          )\n        } else if (input$modality == \"Rowing Ergometer\") {\n          data.frame(\n            Stage = paste0(\"Stage_\", (current_rows + 1):input$stage_counter),\n            Stroke_Rate = 30,\n            Lactate = as.numeric(NA),\n            RPE = as.numeric(NA)\n          )\n        } else {\n          data.frame(\n            Stage = paste0(\"Stage_\", (current_rows + 1):input$stage_counter),\n            Grade = 1,\n            Lactate = as.numeric(NA),\n            RPE = as.numeric(NA)\n          )\n        }\n      written_info(rbind(written_info(), additional_rows))\n    } else if (input$stage_counter < current_rows) {\n      written_info(written_info()[1:input$stage_counter, ])\n    }\n  })\n  \n  observeEvent(input$add_stage, {\n    updateNumericInput(session, \"stage_counter\", value = input$stage_counter + 1)\n  })\n  \n  observeEvent(input$remove_stage, {\n    if (input$stage_counter > 1) {\n      updateNumericInput(session, \"stage_counter\", value = input$stage_counter - 1)\n    }\n  })\n  \n  # Observe changes in modality to reset the table with correct column names\n  observeEvent(input$modality, {\n    written_info(initial_stage_info_data())\n  })\n  \n  # Renders the stage_info table\n  output$stage_table <- renderRHandsontable({\n    if (input$modality == \"Cycle Ergometer\") {\n      rhandsontable(written_info(), rowHeaders = NULL) %>%\n        hot_col(\"Cadence\", type = \"numeric\") %>%\n        hot_col(\"Lactate\", type = \"numeric\") %>%\n        hot_col(\"RPE\", type = \"numeric\")\n    } else if (input$modality == \"Rowing Ergometer\") {\n      rhandsontable(written_info(), rowHeaders = NULL) %>%\n        hot_col(\"Stroke_Rate\", type = \"numeric\") %>%\n        hot_col(\"Lactate\", type = \"numeric\") %>%\n        hot_col(\"RPE\", type = \"numeric\")\n    } else {\n      rhandsontable(written_info(), rowHeaders = NULL) %>%\n        hot_col(\"Grade\", type = \"numeric\") %>%\n        hot_col(\"Lactate\", type = \"numeric\") %>%\n        hot_col(\"RPE\", type = \"numeric\")\n    }\n  })\n  \n  # Update the written_info variable with the contents of the table whenever it's edited\n  observe({\n    if (!is.null(input$stage_table)) {\n      written_info(hot_to_r(input$stage_table))\n    }\n  })\n  \n  ## Server code related to exercise thresholds and zones ===========\n  \n  # Reactive expression to create default info for exercise thresholds\n  initial_threshold_data <- reactive({\n    if (input$modality == \"Treadmill\") {\n      data.frame(\n        Speed_LT1 = as.numeric(NA),\n        VO2_LT1 = as.numeric(NA),\n        BLa_LT1 = as.numeric(NA),\n        Speed_LT2 = as.numeric(NA),\n        VO2_LT2 = as.numeric(NA),\n        BLa_LT2 = as.numeric(NA)\n      )\n    } else {\n      data.frame(\n        Power_LT1 = as.numeric(NA),\n        VO2_LT1 = as.numeric(NA),\n        BLa_LT1 = as.numeric(NA),\n        Power_LT2 = as.numeric(NA),\n        VO2_LT2 = as.numeric(NA),\n        BLa_LT2 = as.numeric(NA)\n      )\n    }\n  })\n  \n  # Reactive expression to create default info for exercise zones\n  initial_zone_data <- reactive({\n    if (input$modality == \"Treadmill\") {\n      data.frame(\n        Speed_Z1 = as.character(NA),\n        HR_Z1 = as.character(NA),\n        RPE_Z1 = as.character(NA),\n        Speed_Z2 = as.character(NA),\n        HR_Z2 = as.character(NA),\n        RPE_Z2 = as.character(NA),\n        Speed_Z3 = as.character(NA),\n        HR_Z3 = as.character(NA),\n        RPE_Z3 = as.character(NA)\n      )\n    } else {\n      data.frame(\n        Power_Z1 = as.character(NA),\n        HR_Z1 = as.character(NA),\n        RPE_Z1 = as.character(NA),\n        Power_Z2 = as.character(NA),\n        HR_Z2 = as.character(NA),\n        RPE_Z2 = as.character(NA),\n        Power_Z3 = as.character(NA),\n        HR_Z3 = as.character(NA),\n        RPE_Z3 = as.character(NA)\n      )\n    }\n  })\n  \n  # Reactive values to hold the exercise thresholds table data\n  threshold_info <- reactiveVal()\n  observe({\n    threshold_info(initial_threshold_data())\n  })\n  \n  # Reactive values to hold the exercise zones table data\n  zone_info <- reactiveVal()\n  observe({\n    zone_info(initial_zone_data())\n  })\n  \n  # Observe changes in modality to reset the exercise thresholds table with correct column names\n  observeEvent(input$modality, {\n    threshold_info(initial_threshold_data())\n  })\n  \n  # Observe changes in modality to reset the zones table with correct column names\n  observeEvent(input$modality, {\n    zone_info(initial_zone_data())\n  })\n  \n  # Renders the exercise thresholds table\n  output$threshold_table <- renderRHandsontable({\n    if (input$modality == \"Treadmill\") {\n      rhandsontable(threshold_info(), rowHeaders = NULL) %>%\n        hot_col(\"Speed_LT1\", type = \"numeric\") %>%\n        hot_col(\"VO2_LT1\", type = \"numeric\") %>%\n        hot_col(\"BLa_LT1\", type = \"numeric\") %>%\n        hot_col(\"Speed_LT2\", type = \"numeric\") %>%\n        hot_col(\"VO2_LT2\", type = \"numeric\") %>%\n        hot_col(\"BLa_LT2\", type = \"numeric\")\n    } else {\n      rhandsontable(threshold_info(), rowHeaders = NULL) %>%\n        hot_col(\"Power_LT1\", type = \"numeric\") %>%\n        hot_col(\"VO2_LT1\", type = \"numeric\") %>%\n        hot_col(\"BLa_LT1\", type = \"numeric\") %>%\n        hot_col(\"Power_LT2\", type = \"numeric\") %>%\n        hot_col(\"VO2_LT2\", type = \"numeric\") %>%\n        hot_col(\"BLa_LT2\", type = \"numeric\")\n    }\n  })\n  \n  # Renders the exercise zones table\n  output$zone_table <- renderRHandsontable({\n    if (input$modality == \"Treadmill\") {\n      rhandsontable(zone_info(), rowHeaders = NULL) %>%\n        hot_col(\"Speed_Z1\") %>%\n        hot_col(\"HR_Z1\") %>%\n        hot_col(\"RPE_Z1\") %>%\n        hot_col(\"Speed_Z2\") %>%\n        hot_col(\"HR_Z2\") %>%\n        hot_col(\"RPE_Z2\") %>%\n        hot_col(\"Speed_Z3\") %>%\n        hot_col(\"HR_Z3\") %>%\n        hot_col(\"RPE_Z3\")\n    } else {\n      rhandsontable(zone_info(), rowHeaders = NULL) %>%\n        hot_col(\"Power_Z1\") %>%\n        hot_col(\"HR_Z1\") %>%\n        hot_col(\"RPE_Z1\") %>%\n        hot_col(\"Power_Z2\") %>%\n        hot_col(\"HR_Z2\") %>%\n        hot_col(\"RPE_Z2\") %>%\n        hot_col(\"Power_Z3\") %>%\n        hot_col(\"HR_Z3\") %>%\n        hot_col(\"RPE_Z3\")\n    }\n  })\n  \n  # Update the written_info variable with the contents of the exercise thresholds table whenever it's edited\n  observe({\n    if (!is.null(input$threshold_table)) {\n      threshold_info(hot_to_r(input$threshold_table))\n    }\n  })\n  \n  # Update the written_info variable with the contents of the exercise zones table whenever it's edited\n  observe({\n    if (!is.null(input$zone_table)) {\n      zone_info(hot_to_r(input$zone_table))\n    }\n  })\n  \n  ## Server code related to exercise modality =======================\n  \n  # Modify UI based on modality chosen\n  renderNumericInput <- function(inputId, labelBase, defaultValues) {\n    renderUI({\n      if (input$modality == \"Cycle Ergometer\") {\n        unit <- ifelse(input$power_unit_switch, \"W/kg\", \"W\")\n        defaultValue <- defaultValues[[paste(\"Cycle Ergometer\", unit)]]\n        label <- paste(labelBase, \" (\", unit, \")\", sep = \"\")\n      } else if (input$modality == \"Rowing Ergometer\") {\n        unit <- ifelse(input$power_unit_switch, \"W/kg\", \"W\")\n        defaultValue <- defaultValues[[paste(\"Rowing Ergometer\", unit)]]\n        label <- paste(labelBase, \" (\", unit, \")\", sep = \"\")\n      } else {\n        unit <- \"kph\"\n        defaultValue <- defaultValues[[\"Treadmill kph\"]]\n        label <- paste(labelBase, \" (\", unit, \")\", sep = \"\")\n      }\n      numericInput(inputId, label, defaultValue)\n    })\n  }\n  \n  observeEvent(input$modality, {\n    if (input$modality %in% c(\"Cycle Ergometer\", \"Rowing Ergometer\")) {\n      output$power_unit_switch_ui <- renderUI({\n        materialSwitch(\"power_unit_switch\", label = \"Input in W/kg\", status = \"primary\", value = FALSE)\n      })\n    } else {\n      output$power_unit_switch_ui <- renderUI({\n        NULL\n      })\n    }\n  })\n  \n  observe({\n    modality <- input$modality\n    \n    # Define labels based on modality\n    labels <- list(\n      protocol_1_start = if (modality == \"Treadmill\") \"Starting Speed\" else \"Starting Power\",\n      protocol_1_increase = if (modality == \"Treadmill\") \"Speed Increments\" else \"Power Increments\",\n      baseline_intensity = if (modality == \"Treadmill\") \"Speed during Baseline Stage\" else \"Power during Baseline Stage\",\n      break_speed = if (modality == \"Treadmill\") \"Speed during Breaks\" else \"Power during Breaks\",\n      protocol_2_start = if (modality == \"Treadmill\") \"Starting Speed of Second Protocol\" else \"Starting Power of Second Protocol\",\n      protocol_2_increase = if (modality == \"Treadmill\") \"Speed Increments of Second Protocol\" else \"Power Increments of Second Protocol\"\n    )\n    \n    output$protocol_1_start_input_ui <- renderNumericInput(\n      \"protocol_1_start_input\", labels$protocol_1_start,\n      list(\"Cycle Ergometer W\" = NA, \"Cycle Ergometer W/kg\" = NA, \"Rowing Ergometer W\" = NA, \"Rowing Ergometer W/kg\" = NA, \"Treadmill kph\" = NA)\n    )\n    output$protocol_1_increase_input_ui <- renderNumericInput(\n      \"protocol_1_increase_input\", labels$protocol_1_increase,\n      list(\"Cycle Ergometer W\" = 25, \"Cycle Ergometer W/kg\" = 0.3, \"Rowing Ergometer W\" = 25, \"Rowing Ergometer W/kg\" = 0.3, \"Treadmill kph\" = 1)\n    )\n    output$baseline_intensity_input_ui <- renderNumericInput(\n      \"baseline_intensity_input\", labels$baseline_intensity,\n      list(\"Cycle Ergometer W\" = 0, \"Cycle Ergometer W/kg\" = 0, \"Rowing Ergometer W\" = 0, \"Rowing Ergometer W/kg\" = 0, \"Treadmill kph\" = 0)\n    )\n    output$break_speed_input_ui <- renderNumericInput(\n      \"break_speed_input\", labels$break_speed,\n      list(\"Cycle Ergometer W\" = 0, \"Cycle Ergometer W/kg\" = 0, \"Rowing Ergometer W\" = 0, \"Rowing Ergometer W/kg\" = 0, \"Treadmill kph\" = 0)\n    )\n    output$protocol_2_start_input_ui <- renderNumericInput(\n      \"protocol_2_start_input\", labels$protocol_2_start,\n      list(\"Cycle Ergometer W\" = NA, \"Cycle Ergometer W/kg\" = NA, \"Rowing Ergometer W\" = NA, \"Rowing Ergometer W/kg\" = NA, \"Treadmill kph\" = NA)\n    )\n    output$protocol_2_increase_input_ui <- renderNumericInput(\n      \"protocol_2_increase_input\", labels$protocol_2_increase,\n      list(\"Cycle Ergometer W\" = 25, \"Cycle Ergometer W/kg\" = 0.35, \"Rowing Ergometer W\" = 25, \"Rowing Ergometer W/kg\" = 0.3, \"Treadmill kph\" = 1)\n    )\n  })\n  \n  \n  # Code to create reactive values for graphing\n  reactive_avg_stage_data_graphing <- reactiveVal(NULL)\n  reactive_parvo_data_graphing <- reactiveVal(NULL)\n  \n  ## Server code related to 'saving' any edits made to the tables ====\n  \n  # Code to create reactive values for the table outputs\n  reactive_test_summary <- reactiveVal(NULL)\n  reactive_avg_stage_data <- reactiveVal(NULL)\n  reactive_parvo_eg_data <- reactiveVal(NULL)\n  \n  # Code that updates each of the table whenever edits are made\n  observe({\n    if (!is.null(input$test_summary_table)) {\n      reactive_test_summary(hot_to_r(input$test_summary_table))\n    }\n  })\n  \n  observe({\n    if (!is.null(input$avg_stage_data_table)) {\n      updated_avg_stage_data <- hot_to_r(input$avg_stage_data_table)\n      reactive_avg_stage_data(updated_avg_stage_data)\n      \n      # Update the graphs to reflect any edits made to the avg_stage_data_table\n      current_avg_stage_data <- reactive_avg_stage_data_graphing()\n      if (!is.null(current_avg_stage_data)) {\n        current_avg_stage_data <- updated_avg_stage_data\n        reactive_avg_stage_data_graphing(current_avg_stage_data)\n      }\n    }\n  })\n  \n  observe({\n    if (!is.null(input$parvo_eg_data_table)) {\n      updated_parvo_eg_data <- hot_to_r(input$parvo_eg_data_table)\n      reactive_parvo_eg_data(updated_parvo_eg_data)\n      \n      # Update the graphs to reflect any edits made to the parvo_eg_data_table\n      current_parvo_data <- reactive_parvo_data_graphing()\n      if (!is.null(current_parvo_data)) {\n        current_parvo_data$parvo_eg_data <- updated_parvo_eg_data\n        reactive_parvo_data_graphing(current_parvo_data)\n      }\n    }\n  })\n  \n  ## Server code related to message prior to processing data =========\n  \n  output$message_before_processing_tst <- renderUI({\n    if (input$process == 0) {\n      h3(\"To preview the Test Summary table, please go to 'Options' and process the data first.\")\n    }})\n  \n  output$message_before_processing_asdt <- renderUI({\n    if (input$process == 0) {\n      h3(\"To preview the Average Stage Data table, please go to 'Options' and process the data first.\")\n    }})\n  \n  output$message_before_processing_pedt <- renderUI({\n    if (input$process == 0) {\n      h3(\"To preview the highest fidelity data table, please go to 'Options' and process the data first.\")\n    }})\n  \n  ## Server code that runs after \"Process\" is initiated =============\n  \n  # Code that reads in the inputs from the Shiny interface and processes the data\n  observeEvent(input$process, {\n    \n    withProgress(message = \"Processing data...\", value = 0, {\n      incProgress(0.05, detail = \"Reading and preparing data...\")\n      \n      file_of_interest <- suppressMessages(read_excel(input$file$datapath))\n      modality <- input$modality\n      power_unit <- input$power_unit_switch\n      has_baseline <- input$has_baseline\n      baseline_time <- convert_to_s(input$baseline_time)\n      baseline_intensity_input <- input$baseline_intensity_input\n      protocol_1_start_input <- input$protocol_1_start_input\n      protocol_1_increase_input <- input$protocol_1_increase_input\n      protocol_1_length_input <- convert_to_s(input$protocol_1_length_input)\n      has_protocol_2 <- input$has_protocol_2\n      when_protocol_2 <- convert_to_s(input$when_protocol_2)\n      protocol_2_start_input <- input$protocol_2_start_input\n      protocol_2_increase_input <- input$protocol_2_increase_input\n      protocol_2_length_input <- convert_to_s(input$protocol_2_length_input)\n      has_break <- input$has_break\n      break_length_input <- convert_to_s(input$break_length_input)\n      break_speed_input <- input$break_speed_input\n      avg_interval <- input$avg_interval\n      include_last_row_input <- input$include_last_row_input\n      cols_of_interest <- input$vars_of_interest\n      end_time_input <- convert_to_s(input$end_time_input)\n      \n      incProgress(0.15, detail = \"Processing and analyzing data...\")\n      \n      # create parvo_data list with 2 tibbles (parvo_metadata and parvo_eg_data) and add some variables of interest\n      parvo_data <-\n        parvo_process(\n          parvo_data_raw = file_of_interest\n        ) %>%\n        print()\n      \n      # Remove all rows that exceed the end of the test\n      parvo_data$parvo_eg_data <-\n        remove_post_test_rows(\n          data = parvo_data$parvo_eg_data,\n          input_time = end_time_input,\n          use_baseline = has_baseline,\n          baseline_length = baseline_time\n        ) %>%\n        print()\n      \n      # make time easier to work with by creating new column rounding time to averaging intervals\n      parvo_data$parvo_eg_data <-\n        replace_with_closest_multiple(\n          data = parvo_data$parvo_eg_data\n        ) %>%\n        print()\n      \n      # add \"Speed\", \"Protocol\", \"Stage\" columns\n      parvo_data$parvo_eg_data <-\n        assign_intensity(\n          data = parvo_data$parvo_eg_data,\n          use_baseline = has_baseline,\n          baseline_length = baseline_time,\n          baseline_intensity = baseline_intensity_input,\n          protocol_1_start = protocol_1_start_input,\n          protocol_1_increase = protocol_1_increase_input,\n          protocol_1_length = protocol_1_length_input,\n          use_protocol_2 = has_protocol_2,\n          time_of_change = when_protocol_2,\n          protocol_2_start = protocol_2_start_input,\n          protocol_2_increase = protocol_2_increase_input,\n          protocol_2_length = protocol_2_length_input,\n          use_break = has_break,\n          break_length = break_length_input,\n          break_speed = break_speed_input\n        ) %>%\n        print()\n      \n      # assign \"Grade/Cadence\", \"Lactate\", and \"RPE\" data columns from Shiny manually inputted table\n      parvo_data$parvo_eg_data <-\n        assign_written_info(\n          data = parvo_data$parvo_eg_data,\n          stage_info = written_info,\n          exercise_mode = modality\n        ) %>%\n        print()\n      \n      incProgress(0.35, detail = \"Creating avg stage data df ...\")\n      \n      # create the average stage data file, while ignoring the columns listed\n      avg_stage_data <-\n        process_stage_avgs(\n          data = parvo_data$parvo_eg_data,\n          include_last_row = include_last_row_input,\n          averaging_interval = avg_interval\n        ) %>%\n        print()\n      \n      # add running economy and metabolic power variables of interest\n      avg_stage_data <-\n        add_re_mp(\n          data = avg_stage_data,\n          athlete_df = parvo_data$parvo_metadata\n        ) %>%\n        print()\n      \n      incProgress(0.5, detail = \"Creating test summary df ...\")\n      \n      # determine peak values for variables of interest and generate new test_summary df\n      test_summary <-\n        process_peak_data(\n          data = parvo_data$parvo_eg_data,\n          meta_data = parvo_data$parvo_metadata,\n          averaging_interval = avg_interval,\n          cols_interest = cols_of_interest,\n          end_time = end_time_input,\n          protocol_1_increase = protocol_1_increase_input,\n          protocol_1_length = protocol_1_length_input,\n          use_break = has_break,\n          break_length = break_length_input,\n          use_protocol_2 = has_protocol_2,\n          protocol_2_increase = protocol_2_increase_input,\n          protocol_2_length = protocol_2_length_input,\n          use_baseline = has_baseline,\n          baseline_length = baseline_time\n        ) %>%\n        print()\n      \n      # assign normative info related to VO2max\n      test_summary <-\n        assign_VO2max_norms(\n          athlete_characteristics_df = test_summary,\n          exercise_mode = modality\n        ) %>%\n        print()\n      \n      # add vVO2max to test_summary\n      test_summary <-\n        workload_at_vo2max(\n          avg_stage_data,\n          summary = test_summary\n        ) %>%\n        print()\n      \n      # add % HRpeak and VO2peak columns to avg_stage_data\n      avg_stage_data <-\n        add_peak_percentages(\n          avg_stage_data,\n          test_summary\n        ) %>%\n        print()\n      \n      # add FATmax and MFO \n      test_summary <-\n        calculate_fatmax(\n          avg_stage_data,\n          test_summary\n        ) %>%\n        print()\n      \n      incProgress(0.7, detail = \"Adjusting to the exercise modality ...\")\n      \n      # adjust parvo_eg_data based on exercise modality\n      parvo_data$parvo_eg_data <-\n        adjust_to_modality_parvo_eg_data(\n          parvo_eg_data = parvo_data$parvo_eg_data,\n          test_summary = test_summary,\n          exercise_mode = modality,\n          power_unit = power_unit\n        ) %>%\n        print()\n      \n      # adjust avg_stage_data based on exercise modality\n      avg_stage_data <-\n        adjust_to_modality_avg_stage_data(\n          avg_stage_data = avg_stage_data,\n          test_summary = test_summary,\n          exercise_mode = modality,\n          power_unit = power_unit\n        ) %>%\n        print()\n      \n      # adjust test_summary based on exercise modality\n      test_summary <-\n        adjust_to_modality_test_summary(\n          test_summary = test_summary,\n          exercise_mode = modality,\n          power_unit = power_unit\n        ) %>%\n        print()\n      \n      # add exercise thresholds from the Shiny manually inputted table\n      test_summary <-\n        add_threshold_zone(\n          threshold_zone_info = threshold_info,\n          test_summary = test_summary\n        ) %>%\n        print()\n      \n      # add exercise zones from the Shiny manually inputted table\n      test_summary <-\n        add_threshold_zone(\n          threshold_zone_info = zone_info,\n          test_summary = test_summary\n        ) %>%\n        print()\n      \n      # Delete the rounded 'Time' column and mutate a minute decimal time column in the avg_stage_data df\n      avg_stage_data <- \n        fix_time(\n          avg_stage_data\n        ) %>%\n        print()\n      \n      # Delete the rounded 'Time' column and mutate a minute decimal time column in the parvo_eg_data df\n      parvo_data$parvo_eg_data <-\n        fix_time(\n          parvo_data$parvo_eg_data\n        ) %>%\n        print()\n      \n      # Delete any columns consisting entirely of NA values. Used to remove lactate, RPE, thresholds, or zones if not inputted\n      avg_stage_data <-\n        remove_empty_columns(\n          avg_stage_data\n        ) %>%\n        print()\n      \n      # Delete any columns consisting entirely of NA values. Used to remove lactate, RPE, thresholds, or zones if not inputted\n      parvo_data$parvo_eg_data <-\n        remove_empty_columns(\n          parvo_data$parvo_eg_data\n        ) %>%\n        print()\n      \n      incProgress(0.9, detail = \"Making tables pretty ...\")\n      \n      # Render the rhandsontable for test_summary\n      output$test_summary_table <- renderRHandsontable({\n        rhandsontable(test_summary, rowHeaders = NULL) %>%\n          hot_col(col = \"Test_Date\", dateFormat = \"YYYY/MM/DD\", type = \"date\")\n      })\n      \n      # Excel download function for test_summary\n      output$download_step_test_summary_data_excel <- downloadHandler(\n        filename = function() {\n          paste(\"test_summary.xlsx\")\n        },\n        content = function(file) {\n          writexl::write_xlsx(reactive_test_summary(), path = file, col_names = TRUE, format_headers = FALSE)\n        }\n      )\n      \n      # CSV download function for test_summary\n      output$download_step_test_summary_data_csv <- downloadHandler(\n        filename = function() {\n          paste(\"test_summary.csv\")\n        },\n        content = function(file) {\n          readr::write_csv(reactive_test_summary(), file, col_names = TRUE)\n        }\n      )\n      \n      # Render the rhandsontable for avg_stage_data\n      output$avg_stage_data_table <- renderRHandsontable({\n        rhandsontable(avg_stage_data, rowHeaders = NULL)\n      }\n      )\n      \n      # Excel download function for avg_stage_data\n      output$download_step_avg_stage_data_excel <- downloadHandler(\n        filename = function() {\n          paste(\"avg_stage_data.xlsx\")\n        },\n        content = function(file) {\n          writexl::write_xlsx(reactive_avg_stage_data(), path = file, col_names = TRUE, format_headers = FALSE)\n        }\n      )\n      \n      # CSV download function for avg_stage_data\n      output$download_step_avg_stage_data_csv <- downloadHandler(\n        filename = function() {\n          paste(\"avg_stage_data.csv\")\n        },\n        content = function(file) {\n          readr::write_csv(reactive_avg_stage_data(), file, col_names = TRUE)\n        }\n      )\n      \n      # Render the rhandsontable for parvo_eg_data\n      output$parvo_eg_data_table <- renderRHandsontable({\n        rhandsontable(parvo_data$parvo_eg_data, rowHeaders = NULL)\n      }\n      )\n      \n      # Excel download function for parvo_eg_data\n      output$download_step_parvo_eg_data_excel <- downloadHandler(\n        filename = function() {\n          paste(\"parvo_eg_data.xlsx\")\n        },\n        content = function(file) {\n          writexl::write_xlsx(reactive_parvo_eg_data(), path = file, col_names = TRUE, format_headers = FALSE)\n        }\n      )\n      \n      # CSV download function for parvo_eg_data\n      output$download_step_parvo_eg_data_csv <- downloadHandler(\n        filename = function() {\n          paste(\"parvo_eg_data.csv\")\n        },\n        content = function(file) {\n          readr::write_csv(reactive_parvo_eg_data(), file, col_names = TRUE)\n        }\n      )\n      \n      # Updates the x- and y-variables of the plots\n      reactive_avg_stage_data_graphing(avg_stage_data)\n      \n      output$avg_stage_x_var_ui <- renderUI({\n        req(reactive_avg_stage_data_graphing())\n        selectInput(\"avg_stage_x_var\", \"Avg Stage X-axis variable:\", choices = names(reactive_avg_stage_data_graphing()), selected = \"Time_m\")\n      })\n      \n      output$avg_stage_y_var_ui <- renderUI({\n        req(reactive_avg_stage_data_graphing())\n        selectInput(\"avg_stage_y_var\", \"Avg Stage Y-axis variable:\", choices = names(reactive_avg_stage_data_graphing()), selected = \"VO2\")\n      })\n      \n      reactive_parvo_data_graphing(parvo_data)\n      \n      output$parvo_data_x_var_ui <- renderUI({\n        req(reactive_parvo_data_graphing())\n        selectInput(\"parvo_data_x_var\", \"Parvo Data X-axis variable:\", choices = names(reactive_parvo_data_graphing()$parvo_eg_data), selected = \"Time_m\")\n      })\n      \n      output$parvo_data_y_var_ui <- renderUI({\n        req(reactive_parvo_data_graphing())\n        selectInput(\"parvo_data_y_var\", \"Parvo Data Y-axis variable:\", choices = names(reactive_parvo_data_graphing()$parvo_eg_data), selected = \"VO2\")\n      })\n      \n      # Sweet Alert processing completion indicator\n      show_alert(\n        title = \"Success!\",\n        text = \"Processing Complete\",\n        type = \"success\",\n        btn_labels = \"Ok\"\n      )\n      \n    })\n  })\n  \n  # Code to render plots\n  output$avg_stage_plot <- renderPlotly({\n    req(reactive_avg_stage_data_graphing()) \n    \n    plot_ly(data = reactive_avg_stage_data_graphing(), x = ~get(input$avg_stage_x_var), y = ~get(input$avg_stage_y_var), \n            type = 'scatter', mode = 'markers') %>%\n      layout(title = 'Avg Stage Data Interactive Plot', \n             xaxis = list(title = input$avg_stage_x_var), yaxis = list(title = input$avg_stage_y_var))\n  })\n  \n  output$parvo_eg_plot <- renderPlotly({\n    req(reactive_parvo_data_graphing()) \n    parvo_eg_data <- reactive_parvo_data_graphing()$parvo_eg_data\n    \n    plot_ly(data = parvo_eg_data, x = ~get(input$parvo_data_x_var), y = ~get(input$parvo_data_y_var), \n            type = 'scatter', mode = 'markers') %>%\n      layout(title = 'Parvo Data Interactive Plot', \n             xaxis = list(title = input$parvo_data_x_var), yaxis = list(title = input$parvo_data_y_var))\n  })\n  \n}\n","type":"text"},{"name":"ui.R","content":"### SETUP ====================================================\n\n# Reading libraries\nsuppressPackageStartupMessages({\n  library(pacman)\n  p_load(shiny,shinydashboard,shinyWidgets,readxl,writexl,fuzzyjoin,tidyverse,rhandsontable,SimplyAgree,zoo,plotly,fresh,here)\n})\n\n# Setting global options \noptions(digits = 5, digits.secs = 3, scipen = 3,\n        dplyr.summarise.inform = FALSE)\n\n# load functions\nsource(here(\"metabolic\",\"all_functions.R\"))\n\n\n\n\n### CREATE SHINY APP USER INTERFACE ==========================\n## Creating sidebar UI =======================================\n\nsidebar <- dashboardSidebar(\n  sidebarMenu(\n    menuItem(\"About the app\", tabName = \"about\", icon = icon(\"circle-question\"),\n             menuSubItem(\"General Outline\", tabName = \"app_outline\"),\n             menuSubItem(\"Usage Guide\", tabName = \"instructions\"),\n             menuSubItem(\"Glossary\", tabName = \"glossary\"),\n             startExpanded = TRUE),\n    menuItem(\"Step Test\", tabName = \"step_test_processor\", icon = icon(\"stairs\"),\n             menuSubItem(\"Options\", tabName = \"step_test_options\"),\n             menuSubItem(\"Test Summary\", tabName = \"step_test_summary\"),\n             menuSubItem(\"Average Stage Data\", tabName = \"step_avg_stage_data\"),\n             menuSubItem(\"Parvo EG Data\", tabName = \"step_parvo_eg_data\"),\n             menuSubItem(\"Graphs\", tabName = \"graphs\")),\n    # menuItem(\"Ramp Test\", tabName = \"ramp_test_processor\", icon = icon(\"chart-line\"),\n    #          menuSubItem(\"Options\", tabName = \"ramp_test_options\"),\n    #          menuSubItem(\"Test Summary\", tabName = \"ramp_test_summary\"),\n    #          menuSubItem(\"Average Stage Data\", tabName = \"ramp_avg_stage_data\"),\n    #          menuSubItem(\"Parvo EG Data\", tabName = \"ramp_parvo_eg_data\")),\n    menuItem(\"ExPhysLab Tools\", tabName = \"ExPhysLab Tools\", lib = \"font-awesome\", icon = icon(\"screwdriver-wrench\"),\n             menuSubItem(\"Lactate Thresholds App\", tabName = \"lactate_thresholds\"),\n             menuSubItem(\"Exercise Thresholds App\", tabName = \"exercise_thresholds\"))\n  )\n)\n\n## Creating body UI ==========================================\n\n# Sets the theme of dashboard\nmy_theme = create_theme(\n  adminlte_color(\n    light_blue = \"#111\"\n  )\n)\n\n# Codes the dashboardBody\nbody <- dashboardBody(\n  use_theme(my_theme),\n  tabItems(\n    tabItem(tabName = \"app_outline\",\n            includeMarkdown(\"App Outline.md\")\n    ),\n    tabItem(tabName = \"instructions\",\n            includeMarkdown(\"Instructions.md\")\n            \n    ),\n    tabItem(tabName = \"glossary\",\n            includeMarkdown(\"Glossary.md\")\n    ),\n    tabItem(tabName = \"step_test_options\",\n            fluidPage(\n              fluidRow(\n                box(\n                  title = \"Exercise Modality\",\n                  width = 6,\n                  status = \"success\", solidHeader = TRUE,\n                  radioGroupButtons(\"modality\", \"Select the Exercise Modality\", choices = c(\"Treadmill\", \"Cycle Ergometer\", \"Rowing Ergometer\"), status = \"primary\")\n                ),\n                box(\n                  title = \"Process the Data\",\n                  width = 6,\n                  status = \"success\", solidHeader = TRUE,\n                  actionButton(\"process\", \"Process Data\")\n                )),\n              fluidRow(\n                box(\n                  title = \"Upload File\",\n                  width = 4,\n                  \"Upload the raw file exported directly from the Parvo Medics' TrueOne\",\n                  status = \"primary\", solidHeader = TRUE,\n                  fileInput(\"file\", \"Upload Parvo File\", accept = c(\".xls\", \".xlsx\"))\n                ),\n                box(\n                  title = \"Written Info\",\n                  width = 4,\n                  \"Fill in the table with the information manually recorded during the test\",\n                  status = \"primary\", solidHeader = TRUE,\n                  h1(\"Number of Stages\"), \n                  fluidRow(\n                    column(2, actionButton(\"remove_stage\", label = NULL, icon = icon(\"minus\"), class = \"btn btn-danger\")),\n                    column(7, numericInput(\"stage_counter\", label = NULL, value = 5, min = 1, width = \"100%\")),\n                    column(2, actionButton(\"add_stage\", label = NULL, icon = icon(\"plus\"), class = \"btn btn-success\"))),\n                  rHandsontableOutput(\"stage_table\")\n                ),\n                box(\n                  title = \"Protocol Options\",\n                  width = 4,\n                  \"Select the protocol design of the GXT\",\n                  status = \"primary\", solidHeader = TRUE,\n                  uiOutput(\"protocol_1_start_input_ui\"),\n                  uiOutput(\"protocol_1_increase_input_ui\"),\n                  uiOutput(\"power_unit_switch_ui\"),\n                  textInput(\"protocol_1_length_input\", \"Length of Stage (m:ss)\", \"3:00\"),\n                  textInput(\"end_time_input\", \"End Time (m:ss)\")\n                )),\n              fluidRow(\n                box(\n                  title = \"Baseline Options\",\n                  width = 4,\n                  \"If a baseline stage was completed, select the options\",\n                  status = \"warning\", solidHeader = TRUE,\n                  switchInput(\"has_baseline\", \"Has Baseline Stage\", TRUE),\n                  textInput(\"baseline_time\", \"Duration of Baseline Stage (m:ss)\", \"1:00\"),\n                  uiOutput(\"baseline_intensity_input_ui\"),\n                ),\n                box(\n                  title = \"Break Options\",\n                  width = 4,\n                  \"If a break was used between submaximal stages, select the options\",\n                  status = \"warning\", solidHeader = TRUE,\n                  switchInput(\"has_break\", \"Has Break\", TRUE),\n                  textInput(\"break_length_input\", \"Length of Breaks (m:ss)\", \"0:30\"),\n                  uiOutput(\"break_speed_input_ui\"),\n                ),\n                box(\n                  title = \"Second Protocol Options\",\n                  width = 4,\n                  \"If there was a change in protocol in the middle of the test, select the options\",\n                  status = \"warning\", solidHeader = TRUE,\n                  switchInput(\"has_protocol_2\", \"Has Second Protocol (i.e., new step parameters)\", TRUE),\n                  textInput(\"when_protocol_2\", \"When Second Protocol Begins (m:ss)\"),\n                  uiOutput(\"protocol_2_start_input_ui\"),\n                  uiOutput(\"protocol_2_increase_input_ui\"),\n                  textInput(\"protocol_2_length_input\", \"Length of Stage of Second Protocol (m:ss)\", \"1:00\")\n                )),\n              fluidRow(\n                box(\n                  title = \"Advanced Options\",\n                  width = 4,\n                  status = \"danger\", solidHeader = TRUE,\n                  #collapsible = TRUE, collapsed = TRUE,\n                  numericInput(\"avg_interval\", \"Calculation Intervals for Averages during Processing (seconds)\", 30),\n                  switchInput(\"include_last_row_input\", \"Include Last Row of Each Stage in Averaging\", FALSE),\n                  pickerInput(\"vars_of_interest\", \"Variables of Interest\", \n                              choices = c(\"Lactate\", \"RPE\", \"HR\", \"VO2\", \"VO2kg\", \"VCO2\", \"RER\", \"RR\", \"VT\", \"VE\"), \n                              selected = c(\"Lactate\", \"RPE\", \"HR\", \"VO2\", \"VO2kg\"), multiple = TRUE)\n                ),\n                box(\n                  title = \"Exercise Thresholds and Zones\",\n                  width = 8,\n                  status = \"danger\", solidHeader = TRUE,\n                  rHandsontableOutput(\"threshold_table\"),\n                  rHandsontableOutput(\"zone_table\")\n                )\n              )\n            )\n    ),\n    tabItem(tabName = \"step_test_summary\",\n            downloadButton(\"download_step_test_summary_data_excel\", \"Excel\"),\n            downloadButton(\"download_step_test_summary_data_csv\", \"CSV\"),\n            fluidRow(\n              box(\n                title = \"Test Summary\",\n                uiOutput(\"message_before_processing_tst\"),\n                rHandsontableOutput(\"test_summary_table\"),\n                width = 12,\n                style = \"height: 85vh; overflow-y: scroll; overflow-x: scroll;\"\n              )\n            )\n    ),\n    tabItem(tabName = \"step_avg_stage_data\",\n            downloadButton(\"download_step_avg_stage_data_excel\", \"Excel\"),\n            downloadButton(\"download_step_avg_stage_data_csv\", \"CSV\"),\n            fluidRow(\n              box(\n                title = \"Average Stage Data\",\n                uiOutput(\"message_before_processing_asdt\"),\n                rHandsontableOutput(\"avg_stage_data_table\"),\n                width = 12,\n                style = \"height: 85vh; overflow-y: scroll; overflow-x: scroll;\"\n              )\n            )\n    ),\n    tabItem(tabName = \"step_parvo_eg_data\",\n            downloadButton(\"download_step_parvo_eg_data_excel\", \"Excel\"),\n            downloadButton(\"download_step_parvo_eg_data_csv\", \"CSV\"),\n            fluidRow(\n              box(\n                title = \"Parvo EG Data\",\n                uiOutput(\"message_before_processing_pedt\"),\n                rHandsontableOutput(\"parvo_eg_data_table\"),\n                width = 12\n                #, style = \"height: 85vh; overflow-y: scroll; overflow-x: scroll;\"\n              )\n            )\n    ),\n    tabItem(tabName = \"graphs\",\n            sidebarLayout(\n              sidebarPanel(\n                # Controls for Parvo EG Data\n                fluidRow(\n                  box(\n                    title = \"Parvo EG Graph Controls\",\n                    status = \"primary\",\n                    solidHeader = TRUE,\n                    width = 12,\n                    uiOutput(\"parvo_data_y_var_ui\"),\n                    uiOutput(\"parvo_data_x_var_ui\")\n                  )\n                ),\n                # Controls for Average Stage Data\n                fluidRow(\n                  box(\n                    title = \"Average Stage Graph Controls\",\n                    status = \"primary\",\n                    solidHeader = TRUE,\n                    width = 12,\n                    uiOutput(\"avg_stage_y_var_ui\"),\n                    uiOutput(\"avg_stage_x_var_ui\")\n                  )\n                )\n              ),\n              mainPanel(\n                box(\n                  title = \"Parvo Data Plot\",\n                  status = \"primary\",\n                  solidHeader = TRUE,\n                  width = NULL,\n                  plotlyOutput(\"parvo_eg_plot\")\n                ),\n                box(\n                  title = \"Average Stage Data Plot\",\n                  status = \"primary\",\n                  solidHeader = TRUE,\n                  width = NULL,\n                  plotlyOutput(\"avg_stage_plot\")\n                )\n              )\n            )\n    ),\n    # tabItem(tabName = \"ramp_test_options\",\n    #         mainPanel(\"Coming soon\")\n    # ),\n    # tabItem(tabName = \"ramp_test_summary\",\n    #         mainPanel(\"Coming soon\")\n    # ),\n    # tabItem(tabName = \"ramp_avg_stage_data\",\n    #         mainPanel(\"Coming soon\")\n    # ),\n    # tabItem(tabName = \"ramp_parvo_eg_data\",\n    #         mainPanel(\"Coming soon\")\n    # ),\n    tabItem(tabName = \"lactate_thresholds\",\n            tags$iframe(src = \"https://www.exphyslab.com/lactate\",\n                        width = \"100%\",\n                        style = \"height: 85vh;\")\n    ),\n    tabItem(tabName = \"exercise_thresholds\",\n            tags$iframe(src = \"https://www.exercisethresholds.com/analyze\",\n                        width = \"100%\",\n                        style = \"height: 85vh;\")\n    )\n  )\n)\n\n# Code to define UI\nui <- dashboardPage(\n  dashboardHeader(title = \"Expired Gas Data Processing\"),\n  sidebar,\n  body\n)\n","type":"text"},{"name":"App Outline.md","content":"# App Outline\r\n\r\nThis application is intended to assist with the processing of pulmonary gas exchange and ventilatory data measured using the Parvo Medics True One 2400 metabolic cart. Other metabolic carts are currently not supported.\r\n\r\nPlease refer to the **Usage Guide** tab for instructions and information on using the application before your first use.\r\n\r\n<br>\r\n\r\n## Contact\r\nIf you have any questions, please contact Andy Hung at ahung@csipacific.ca\r\n\r\n<br>\r\n\r\n*Last update: Sept 9, 2024*\r\n\r\n<br>\r\n\r\n**Fixes in latest update:**\r\n- Peak intensity calculation fixed\r\n- Changed so real time is entered into 'End Time (m:ss)' and 'When Second Protocol Begins (m:ss)', rather than MMC time\r\n- Removed extra rows of data that exceed the end test time\r\n- More stop messages so errors can be better diagnosed\r\n- Added 'Rowing Ergometer' feature\r\n- Added 'Training Zones' feature\r\n\r\n**Planned large updates to come:**\r\n- Automatically update a database\r\n- Ramp test\r\n- MRT calculation\r\n\r\n**Known bugs / Fixes to come:**\r\n- If use 'Break' and workload does not equal to 0, will populate odd looking row into 'Average Stage Data Table'\r\n- Ordering of variables in graphs (e.g., 'Time' in m:ss format)\r\n- Improve UI layout\r\n","type":"text"},{"name":"Glossary.md","content":"# Glossary\r\nThis section explains what each of the variables mean.\r\n\r\n### Test Summary Variables\r\n- *Name*: Name of athlete in \"last name, first name\" format.\r\n- *Test_Date*: Date of when the test was completed in the TrueOne 2400 MMC computer.\r\n- *Test_Time*: Time of day when the test was began in the TrueOne 2400 MMC computer.\r\n- *Age*: Age of athlete in years.\r\n- *Sex*: Sex of athlete.\r\n- *Height*: Height of athlete in centimeteres.\r\n- *Weight*: Weight of athlete in kilograms.\r\n- *BMI*: Body mass index of athlete in kg/m<sup>2<\/sup>.\r\n- *Temperature*: Temperature entered into the TrueOne 2400 MMC computer when test was administered.\r\n- *RH*: Relative humidity entered into the TrueOne 2400 MMC computer when test was administered.\r\n- *Test_duration*: Duration of the test.\r\n- *Workload_peak*: The peak workload completed during the test and calculated in a pro rata manner.\r\n- *Peak values*: The peak value achieved during the test and calculated using duration set in the 'Calculation Intervals for Averages during Processing' argument in the 'Advanced Settings'.\r\n- *VO2max_age_pred*: The predicted V̇O<sub>2<\/sub>max of the individual, based on their sex, age, and weight. Reference equation derived from the FRIEND cohort (*doi:* [10.1016/j.pcad.2017.03.002](https://doi.org/10.1016/j.pcad.2017.03.002)).\r\n- *VO2max_percent_age_pred*: The ratio of the V̇O<sub>2<\/sub>peak measured during the test to the V̇O<sub>2<\/sub>max predicted using the FRIEND reference equation.\r\n- *VO2max_percentile*: Percentile the V̇O<sub>2<\/sub>peak measured during the tes falls under, based on reference standards determined from the FRIEND cohort (*doi:* [10.1016/j.mayocp.2021.08.020](https://doi.org/10.1016/j.mayocp.2021.08.020)). Percentiles are only available for tests completed using a treadmill or cycling ergometer.\r\n- *VO2max_percentile_desc*: Qualitative descriptors of V̇O<sub>2<\/sub>peak measured during the test. Based on reference standards (i.e., percentiles) determined from the FRIEND cohort (*doi:* [10.1016/j.mayocp.2021.08.020](https://doi.org/10.1016/j.mayocp.2021.08.020)) and descriptors from the [ACSM's Guidelines for Exercise Testing and Prescription, 11th. ed](https://www.acsm.org/education-resources/books/guidelines-exercise-testing-prescription). Descriptors are only available for tests completed using a treadmill or cycling ergometer.\r\n- *Workload at VO2max*: The estimated workload at V̇O<sub>2<\/sub>max calculated by firstly regressing V̇O<sub>2<\/sub> on workload, and then extrapolating the relationship to the measured V̇O<sub>2<\/sub>peak on the test.\r\n- *Fatmax_workload*: The estimated workload that elicits the highest rate of fat oxidation. Determined by calculating fat oxidation values for each workload, depicting it graphically as a function of workload, and then constructing a third-order polynomial curve with intersection in (0,0) (*doi:* [10.1007/s00421-006-0290-x](https://doi.org/10.1016/j.pcad.2017.03.002)).\r\n- *Fatmax_HR*: The estimated %HRpeak that elicits the highest rate of fat oxidation. Calculated using the same method as Fat<sub>max<\/sub>_workload.\r\n- *Fatmax_VO2*: The estimated %VO2peak that elicits the highest rate of fat oxidation. Calculated using the same method as Fat<sub>max<\/sub>_workload.\r\n- *MFO_gmin*: The estimated maximal rate of fat oxidation in grams/minute. Calculated using the same method as Fat<sub>max<\/sub>_workload.\r\n\r\n### Average Stage Data\r\n- *Time_mss*: End time in minute:second format for the given stage. \r\n- *Time_m*: End time in minute decimal format for the given stage.\r\n- *Time_s*: End time in seconds for the given stage.\r\n- *CHO_gmin*: CHO oxidation in grams/minute, estimated using the [Peronnet & Massicotte, 1991](https://pubmed.ncbi.nlm.nih.gov/1645211/) equation.\r\n- *FAT_gmin*: Fat oxidation in grams/minute, estimated using the [Peronnet & Massicotte, 1991](https://pubmed.ncbi.nlm.nih.gov/1645211/) equation.\r\n- *CHO_kcalmin*: CHO oxidation in kilocalories/minute, with the assumption that 1 gram of CHO provides approximately 4 kilocalories.\r\n- *FAT_kcalmin*: Fat oxidation in kilocalories/minute, with the assumption that 1 gram of fat provides approximately 9 kilocalories.\r\n- *Total_kcalmin*: Estimated total energy expenditure in kilocalories/minute, with the assumption of zero protein metabolism.\r\n- *Total_kcalhr*: Estimated total energy expenditure in kilocalories/hour, with the assumption of zero protein metabolism.\r\n- *O2_kJL*: The amount of energy expended per liter of O<sub>2<\/sub> consumed in kilojoules/liter, estimated using the [Peronnet & Massicotte, 1991](https://pubmed.ncbi.nlm.nih.gov/1645211/) equation.\r\n- *O2_kcalL*: The amount of energy expended per liter of O<sub>2<\/sub> consumed in kilocalories/liter, estimated using the [Peronnet & Massicotte, 1991](https://pubmed.ncbi.nlm.nih.gov/1645211/) equation.\r\n- *WE_kJmin*: Estimated aerobic work expenditure in kilojoules/minute.\r\n- *P_Js*: Estimated aerobic power in joules/second (i.e., watts).\r\n- *EE_kcalmin*: Estimated aerobic energy expenditure in kilocalories/minute.\r\n- *MP_kJs*: Estimated metabolic power in kilojoules/second, estimated using the [Peronnet & Massicotte, 1991](https://pubmed.ncbi.nlm.nih.gov/1645211/) equation.\r\n- *MP_Wkg*: Estimated metabolic power in watts/kilogram, estimated using the [Peronnet & Massicotte, 1991](https://pubmed.ncbi.nlm.nih.gov/1645211/) equation.\r\n- *RE_mlkgkm*: Running economy expressed in milliliters of O<sub>2<\/sub>/kilogram/kilometer.\r\n- *RE_kcalkm*: Running economy expressed in kilocalories/kilometer.\r\n- *RE_kcalkgkm*: Running economy expressed in kilocalories/kilogram/kilometer.\r\n- *CE_LminW*: Cycling economy expressed in liters of O<sub>2<\/sub>/minute/watts.\r\n- *CE_WLmin*: Cycling economy expressed in watts/(liter of O<sub>2<\/sub>/minute).\r\n- *CE_kJL*: Cycling economy expressed in kilojoules/liter of O<sub>2<\/sub>.\r\n- *GE_Js*: Gross economy calculated as the ratio of work accomplished to energy expended in joules/second.\r\n- *GE_kcalmin*: Gross economy calculated as the ratio of work accomplished to energy expended in kilocalories/minute.\r\n- *Perc_HR_peak*: Percent of peak heart rate achieved during the test.\r\n- *Perc_VO2_peak*: Percent of peak V̇O<sub>2<\/sub>max achieved during the test.","type":"text"},{"name":"Instructions.md","content":"### General Overview\r\nThere are three tabs:\r\n1. <ins>About the app<\/ins>: Find information to help you get started and understand key terms found in the application, such as the **Usage Guide** and **Glossary**\r\n2. <ins>Step Test<\/ins>: Enter your step test protocol and analysis preferences. Preview the results with tables and plots to visualize the output.\r\n3. <ins>ExPhysLab Tools<\/ins>: Access the *Lactate Thresholds App* and *Exercise Thresholds App* from ExPhysLab to help you identify the physiological thresholds.\r\n<br>\r\n\r\n### Instructions on how to process the data\r\n\r\n#### Upload File\r\n- Upload the file containing the expired gas data from the metabolic cart. The file must adhere to the following:\r\n  1. The file must be in *.xlsx* or *.xls* format.\r\n     - Currently, the *.xls* file directly exported from the True One 2400 is not compatible.\r\n     - As an imperfect workaround, please open and re-save the file as either a *.xlsx* or *.xls* file.\r\n  2. The *Time* column in the file must be in **m:ss** format, not in decimal minutes.\r\n  3. The following columns must be present in the file and in the following order:\r\n     - \"TIME\", \"VO2\", \"VO2/kg\", \"VCO2\", \"RER\", \"RR\", \"Vt\", \"VE\", \"VE/VO2\", \"VE/VCO2\", \"FEO2\", \"FECO2\", and \"HR\".\r\n\r\n#### Written Info\r\n- Fill in the table with the information that was manually recorded during the test.\r\n- Indicate how many steps (i.e., stages) were completed (including rest). You can either use the buttons on the screen, or manually type in the number of stages in the box.\r\n  - Please note: This table contains *Cadence*, *Stroke Rate*, and *Grade*. As such, ensure you populate enough rows for all the stages, even if *Lactate* or *RPE* data was not collected for that stage.\r\n\r\n#### Protocol Options\r\n- Fill in the test protocol.\r\n  - For treadmill assessments, please input the work rate in kilometers/hour, rather than miles/hour.\r\n  - For cycle and rowing ergometer assessments, you have the option of inputting the work rates in watts or watts/kilogram.\r\n- For *End Time (m:ss)*, input the actual duration of the test, not when the test ended according to MMC time.\r\n  - E.g., If an athlete rests for 1 minute prior to the start of the test and cycles for 25:03 afterwards, enter '25:03' and not '26:03'.\r\n\r\n#### Baseline Options\r\n- Indicate whether a baseline stage was completed prior to the start of the test. If a baseline stage was completed, indicate the duration and intensity of the stage.\r\n  - E.g., If an athlete rests for 5 minutes prior to the start of the test, enter '5:00' and '0'.\r\n  - E.g., If an athlete warm-ups for 10 minutes at 75 W prior to the start of the test, enter '10:00' and '75'.\r\n\r\n#### Break Options\r\n- Indicate whether there are 'breaks' (or a temporary change in protocol) in between the stages of the test. If breaks were used, indicate the duration and intensity of the stage.\r\n  - E.g., If the athlete completes a GXT with blood lactate measurements on the treadmill and stopped for 30 seconds between each stage, enter '0:30' and '0'.\r\n\r\n#### Second Protocol\r\n- Indicate whether there was a permanent change in protocol at some point during the test. If so, indicate when this change occured, the starting intensity of the new protocol, the increment in work rate between stages, and then duration of the stages.\r\n- For *When Second Protocol Begins (m:ss)*, input the time when the protocol transition occurs during the test, not when the test ended according to MMC time.\r\n\r\n#### Advanced Options\r\n- *Calculation Intervals for Averages during Processing (seconds)* sets the duration of data that will be used in the assignment of an \"average\" for a given stage.\r\n  - E.g., \"30\" means the last 30 seconds of data for a given stage will be averaged.\r\n- *Include Last Row of Each Stage in Averaging* indicates whether the last row of data in each stage will be included in the calculation of the \"average\" for a given stage during \"protocol_1\".\r\n  - Averages for \"protocol_2\" stages are always calculated including the last row.\r\n  - Please note: This feature is currently coded to only allow the user to exclude the very last row of a stage. As such, it is influenced by the exported average interval duration.\r\n- *Variables of Interest* indicates which variables you are interested in calculating the \"peak\".\r\n  - This is reflected in the \"test_summary\" file.\r\n  - Defaults to \"Lactate\", \"RPE\", \"HR\", \"VO2\", and \"VO2kg\".\r\n\r\n<br>\r\n\r\n### Previewing the outputs\r\nAfter you've entered all the arguments and initialized the processing of the data, a *Success* alert will appear. However, please be cognizant that this simply informs you that the code was successfully able to be run. As such, it is recommended you scan the outputs to ensure the data has been processed correctly.\r\n\r\nThis can be done in tabular form, of which there are 3 tabular outputs:\r\n1. <ins>Test Summary<\/ins>: Contains the test-level data, such as athlete information, test information, and peak values.\r\n2. <ins>Average Stage Data<\/ins>: Contains average data for each stage and metrics that can be subsequently derived, such as substrate oxidation and exercise efficiency.\r\n3. <ins>Parvo EG Data<\/ins>: Is the dataset containing the highest resolution data.\r\n\r\nIf there are errors, please go back to the **Options** tab and ensure all the protocol arguments have been entered correctly. If need be, the tables can be manually altered; simply double-click the cell and change the value. For example, the peak HR registered on a Polar watch HR receiver may be greater than that on the True One. As such, you can manually change the HR_peak value. If you're happy with the tables as they are, the tables can be downloaded in either Excel and CSV formats. \r\n\r\nTo quickly graphically visualize the data, the **Graphs** sub-tab allows you to plot any two of the variables against one another from either the <ins>Average Stage Data<\/ins> or the <ins>Parvo EG Data<\/ins> datasets. If any values are updated in the tables, they will also be reflected in the plots.","type":"text"},{"name":"all_functions.R","content":"# Create parvo_data list with 2 df (parvo_metadata and parvo_eg_data)\n# Add some variables of interest\nparvo_process <- function(\n    parvo_data_raw,\n    col_names = c(\n      \"Time\", \"VO2\", \"VO2kg\", \"VCO2\",\n      \"RER\", \"RR\", \"VT\", \"VE\", \"VEVO2\", \"VEVCO2\",\n      \"FEO2\", \"FECO2\", \"HR\")){\n  \n  # Ensures the raw Parvo export file has all the variables of interest in the expired gas section\n  variables_of_interest_row <- which(grepl(\"---------\", parvo_data_raw[[1]]))\n  \n  required_variables <- c(\"TIME\", \"VO2\", \"VO2/kg\", \"VCO2\", \"RER\", \"RR\", \"Vt\", \"VE\", \"VE/\", \"VE/\", \"FEO2\", \"FECO2\", \"HR\")\n  if (variables_of_interest_row - 3 < 1 || !identical(required_variables, as.character(parvo_data_raw[variables_of_interest_row - 3, ]))) {\n    stop(\"Error: The required expired gas variables of interest are not found or do not match the expected order.\")\n  }\n  \n  # Ensures the first cell below \"---------\" contains a colon, which is used to assume time is exported in m:ss (and not in minute decimal format)\n  if (!grepl(\":\", parvo_data_raw[variables_of_interest_row + 1, 1])) {\n    stop(\"Error: Please export the Time column in 'm:ss' format.\")\n  }\n  \n  parvo_eg_data <- parvo_data_raw %>%\n    # remove metadata details so you only have df if expired gas data\n    slice_tail(n = -which(grepl(\"---------\", parvo_data_raw[[1]]))) %>% \n    # rename columns from col_names input\n    rename_with(~ col_names) %>% \n    # remove footer (Max, Events, and Summary) details, starting with first NA row in Time column\n    slice(-(head(which(is.na(Time)),1):nrow(.))) %>%\n    # convert all but Time column to numeric\n    mutate(across(-Time, ~ as.numeric(.))) %>% \n    # hide warnings when reading mixed data types\n    suppressWarnings() %>%\n    # create new Time column in seconds\n    mutate(Time_mss = Time) %>%\n    relocate(Time_mss, .before = Time) %>%\n    mutate(Time = lubridate::period_to_seconds(lubridate::ms(Time, roll = TRUE))) %>%\n    \n    # filter erroneous data where VO2 or VT below empirical cutoff. will keep the row of data, but replaces all the data with NA\n    mutate(\n      across(-c(Time, matches(\"Time_mss\")), ~ case_when(\n        VO2 < 0.1 | VT < 0.1 ~ NA_real_,\n        TRUE ~ .)),\n    ) %>%\n    \n    # create columns with additional variables of interest\n    mutate(\n      # substrate oxidation in g/min (VO2 & VCO2 in L/min), from Peronnet & Massicotte, 1991\n      CHO_gmin = 4.585 * VCO2 - 3.226 * VO2,\n      FAT_gmin = 1.695 * VO2 - 1.701 * VCO2,\n      # Jeukendrup & Wallis, 2005 (50-75% Intensity)\n      # Double check with Trent if go with 9 and 4 kcal/g\n      CHO_kcalmin = CHO_gmin * 4,\n      FAT_kcalmin = FAT_gmin * 9,\n      Total_kcalmin = FAT_kcalmin + CHO_kcalmin,\n      Total_kcalhr = Total_kcalmin * 60,\n      # calculate O2eq in kJ/L & kcal/L, from Péronnet & Massicotte, 1991\n      O2_kJL = 16.8835 + 4.8353 * pmin(pmax(RER, 0.7036), 0.9961),\n      O2_kcalL = 4.0372 + 1.1563 * pmin(pmax(RER, 0.7036), 0.9961),\n      # Aerobic Work Expenditure in kJ/min (VO2 in L/min, O2kJ in kJ/L)\n      WE_kJmin = VO2 * O2_kJL,\n      # Aerobic Power in W = J/sec (VO2 in L/min, O2kJ in kJ/L)\n      P_Js = VO2 * O2_kJL * 1000/60,\n      # Aerobic Energy Expenditure in kcal/min (VO2 in L/min, O2kcal in kcal/L)\n      EE_kcalmin = VO2 * O2_kcalL\n    )\n  \n  # create df with test metadata\n  parvo_metadata <- \n    tibble(\n      Name = as.character(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Name\", .)))[[which(grepl(\"Name\", parvo_data_raw)) + 1]]),\n      Test_Date = as.character(paste(parvo_data_raw[2, 2], sprintf(\"%02d\", as.numeric(parvo_data_raw[2, 4])), sprintf(\"%02d\", as.numeric(parvo_data_raw[2, 6])), sep = \"/\")),\n      Test_Time = paste(paste(parvo_data_raw[2, 7:9], collapse = \"\"), parvo_data_raw[2, 10], sep = \":\"),\n      Age = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Age\", .)))[[which(grepl(\"Age\", parvo_data_raw)) + 1]]),\n      Sex = case_when(\n        grepl(\"F\", filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Sex\", .)))[[which(grepl(\"Sex\", parvo_data_raw)) + 1]]) ~ \"female\",\n        grepl(\"M\", filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Sex\", .)))[[which(grepl(\"Sex\", parvo_data_raw)) + 1]]) ~ \"male\"),\n      Height = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Height\", .)))[[which(grepl(\"Height\", parvo_data_raw)) + 3]]),\n      Weight = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Weight\", .)))[[which(grepl(\"Weight\", parvo_data_raw)) + 3]]),\n      BMI = round(Weight / (Height/100)^2 , 2),\n      Temperature = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Insp. temp\", .)))[[which(grepl(\"Insp. temp\", parvo_data_raw)) + 1]]),\n      RH = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Insp. humidity\", .)))[[which(grepl(\"Insp. humidity\", parvo_data_raw)) + 1]])\n    )\n  \n  return(list(parvo_eg_data = parvo_eg_data, parvo_metadata = parvo_metadata))\n}\n\n\n##########################\n# Remove all rows that exceed the end of the test\nremove_post_test_rows <- function(data,input_time,use_baseline,baseline_length) {\n  \n  # Adjust the input_time if there is a baseline stage\n  if (use_baseline) {\n    input_time <- input_time + baseline_length\n  }\n  \n  # Find the index of the maximum value where Time is less than or equal to input_time\n  closest_index <- which.max(data$Time[data$Time <= input_time])\n  \n  # Check if there's an exact match\n  if (any(data$Time == input_time)) {\n    # If an exact match is found, get its index\n    exact_match_index <- which(data$Time == input_time)[1]\n    # Keep rows up to and including the exact match\n    result_data <- data[1:exact_match_index, ]\n  } else {\n    # If no exact match, find the closest preceding time and include the first row after it\n    if (length(closest_index) == 0) {\n      # Handle case when all times are greater than input_time\n      result_data <- data\n    } else {\n      # Ensure we do not exceed the bounds of the dataframe\n      end_index <- min(closest_index + 1, nrow(data))\n      result_data <- data[1:end_index, ]\n    }\n  }\n  \n  return(result_data)\n}\n\n###############################\n# Round time to make it easier to work with\nreplace_with_closest_multiple <- function(data) {\n  # Creates a new column to \"store\" the original \"Time\" values\n  data <- data %>%\n    mutate(Time_s = Time, .before = Time)\n  \n  # Replace the values with rounded \"Time\" values\n  rounded_diff <- round(mean(diff(data$Time)))\n  data$Time <- round(data$Time / rounded_diff) * rounded_diff\n  return(data)\n}\n\n################################\n# Add \"Speed\", \"Protocol\", and \"Stage\" columns\nassign_intensity <- function(\n    data, protocol_1_start, protocol_1_increase, protocol_1_length,\n    use_baseline = FALSE, baseline_length = 0, baseline_intensity = 0,\n    use_protocol_2 = FALSE, time_of_change = 0, protocol_2_start = 0, protocol_2_increase = 0, protocol_2_length = 0,\n    use_break = FALSE, break_length = 0, break_speed = 0) {\n  \n  # adjust protocol_1_length so it either includes or doesn't include break_length, and also + 0.1 to ensure calculations do not exclude any required time period.\n  adjusted_protocol_1_length <- ifelse(use_break, protocol_1_length + break_length + 0.1, protocol_1_length + 0.1)\n  \n  # adjust time_of_change (when protocol_1 transitions to protocol_2) so that it only includes the first row after the time_of_change \n  adjusted_time_of_change <- time_of_change + 0.1\n  \n  if (use_baseline) {\n    adjusted_time_of_change <- adjusted_time_of_change + baseline_length\n  }\n  \n  # assign \"Speed\" column, with toggles for baseline, breaks, and change in step parameters\n  data <- data %>%\n    mutate(Speed = case_when(\n      use_baseline & Time <= baseline_length ~ baseline_intensity,\n      !use_protocol_2 | (use_protocol_2 & Time <= adjusted_time_of_change) ~ protocol_1_start + protocol_1_increase * ((Time - ifelse(use_baseline, baseline_length, 0)) %/% adjusted_protocol_1_length),\n      use_protocol_2 & Time > adjusted_time_of_change ~ protocol_2_start + protocol_2_increase * ((Time - adjusted_time_of_change) %/% protocol_2_length)\n    )) %>%\n    \n    # assign \"Protocol\" column, with toggles for baseline and change in step parameters\n    mutate(Protocol = case_when(\n      !(use_baseline | use_protocol_2) ~ \"protocol_1\",\n      use_baseline & !use_protocol_2 ~ ifelse(Time <= baseline_length, \"baseline\", \"protocol_1\"),\n      !use_baseline & use_protocol_2 ~ ifelse(Time > adjusted_time_of_change, \"protocol_2\", \"protocol_1\"),\n      use_baseline & use_protocol_2 ~ case_when(\n        Time <= baseline_length ~ \"baseline\",\n        Time <= adjusted_time_of_change ~ \"protocol_1\",\n        TRUE ~ \"protocol_2\"\n      )\n    )) %>%\n    \n    # assign \"Stage\" column based on rank, with - 1 to make sure it always starts at \"Stage_0\"\n    mutate(Stage = paste0(\"Stage_\", dense_rank(Speed) - 1))\n  \n  # adjust \"Speed\" column based on whether there are breaks\n  if (use_break) {\n    data <- data %>%\n      group_by(Stage) %>%\n      mutate(max_time = max(Time),\n             total_stage_time = max_time - min(Time) + mean(diff(Time)),\n             Speed = if_else((Protocol == \"protocol_1\") & (total_stage_time == adjusted_protocol_1_length - 0.1) & (Time > (max_time - break_length)), break_speed, Speed)) %>%\n      ungroup() %>%\n      select(-max_time, -total_stage_time)\n  }\n  \n  # adjust \"Protocol\" column so it starts at \"Stage_1\" if no baseline\n  if (data$Protocol[1] == \"protocol_1\") {\n    data <- data %>%\n      mutate(Stage = str_replace(Stage, \"(\\\\d+)$\", function(x) as.character(as.numeric(x) + 1)))\n  }\n  \n  # adjust \"Protocol\" column so all \"Stage_0\" are replaced with \"baseline\"\n  data <- data %>%\n    mutate(Stage = str_replace_all(Stage, \"Stage_0\", \"baseline\"))\n  \n  # add in min/km and m:ss, and rename Speed to Speed_kph\n  data <- data %>%\n    mutate(Speed_minkm_dec = if_else(Speed == 0, NA_real_, 60 / Speed),\n           Speed_minkm = if_else(\n             is.na(Speed_minkm_dec),\n             NA_character_,\n             sprintf(\"%d:%02d\", floor(Speed_minkm_dec), round((Speed_minkm_dec %% 1) * 60)))) %>%\n    rename(Speed_kph = Speed) %>%\n    relocate(Speed_minkm, Speed_minkm_dec, .after = Speed_kph)\n  \n  return(data)\n}\n\n###################################\n# Assign \"Grade/Cadence\", \"Lactate\", and \"RPE\" columns from Shiny manually inputted table\nassign_written_info <-function(data,stage_info,exercise_mode) {\n  stage_info <- stage_info()\n  \n  # Determine the column name based on the exercise_mode\n  # col_name <- if (exercise_mode == \"Cycle Ergometer\") \"Cadence\" else \"Grade\"\n  \n  col_name <- switch(exercise_mode,\n                     \"Cycle Ergometer\" = \"Cadence\",\n                     \"Rowing Ergometer\" = \"Stroke_Rate\",\n                     \"Grade\")\n  \n  # Match stages and assign Grade/Cadence, Lactate, and RPE values\n  data <- data %>%\n    mutate(\n      !!col_name := stage_info[[col_name]][match(Stage, stage_info$Stage)],\n      Lactate = stage_info$Lactate[match(Stage, stage_info$Stage)],\n      RPE = stage_info$RPE[match(Stage, stage_info$Stage)]\n    )\n  \n  return(data)\n}\n\n\n#############################\n## Creating average stage data file ==========================\n\n# Create the initial average stage df\n# Function will not try to average the columns listed\nprocess_stage_avgs <-function(\n    data,\n    averaging_interval,\n    include_last_row,\n    columns_to_exclude = c(\n      \"Time_mss\", \"Time_s\", \"Time\",\n      \"Speed_minkm\", \"Speed_minkm_dec\", \"Protocol\",\n      \"Stage\", \"Lactate\", \"RPE\",\n      \"Grade\", \"Cadence\", \"Stroke_Rate\")) {\n  \n  # Exclude rows with 0 Speed or \"baseline\" Stage\n  filtered_data <- data %>%\n    filter(Speed_kph != 0 & Stage != \"baseline\")\n  \n  # Calculate the number of rows for the averaging interval based on the Time column\n  rows_for_interval <- averaging_interval / diff(head(filtered_data$Time, 2))\n  \n  # Group by Speed_kph and calculate the average for all columns except excluded ones\n  avg_data <- filtered_data %>%\n    group_by(Speed_kph) %>%\n    mutate(across(!any_of(columns_to_exclude),\n                  ~ rollapplyr(.x, rows_for_interval, mean, align = \"right\", fill = NA))) %>%\n    filter(!is.na(VO2)) %>%\n    ungroup()\n  \n  # Extract the appropriate row based on include_last_row\n  final_data <- avg_data %>%\n    group_by(Speed_kph) %>%\n    slice(if (include_last_row) n() else if (any(Protocol == 'protocol_1')) n() - 1 else n()) %>%\n    distinct(Speed_kph, .keep_all = TRUE) %>%\n    ungroup()\n  \n  return(final_data)\n}\n\n\n#######################################################\n# Add running economy and metabolic power variables of interest\nadd_re_mp <-function(data,athlete_df) {\n  \n  re_mp_data <- data %>%\n    mutate(\n      # calculate metabolic power in kJ/s using Peronnet and Massicotte equation\n      MP_kJs = (16.89 * VO2 / 60) + (4.84 * VCO2 / 60),\n      # expressing metabolic power as W/kg\n      MP_Wkg = MP_kJs / athlete_df$Weight * 1000,\n      # calculate running economy in ml/kg/km\n      RE_mlkgkm = VO2kg * Speed_minkm_dec,\n      # calculate running economy in kcal/km\n      RE_kcalkm = Total_kcalmin * Speed_minkm_dec,\n      # calculate running economy in kcal/kg/km\n      RE_kcalkgkm = RE_kcalkm / athlete_df$Weight) %>%\n    relocate(RE_mlkgkm, RE_kcalkm, RE_kcalkgkm, MP_kJs, MP_Wkg, .before = Speed_kph)\n  \n  return(re_mp_data)\n}\n\n######################################################################\n## Calculate test summary level variables of interest ===========\n\n# Determine peak values for variables of interest and generate test_summary df\nprocess_peak_data <- function(\n    data, meta_data, averaging_interval, cols_interest, end_time, \n    protocol_1_increase, protocol_1_length,\n    use_break, break_length, \n    use_protocol_2, protocol_2_increase, protocol_2_length,\n    use_baseline, baseline_length) {\n  \n  # Helper function to calculate peak values for a column\n  calculate_peak <- function(data, col_interest) {\n    \n    # Filter data\n    filtered_data <- data %>% filter(Speed_kph != 0 & Stage != \"baseline\")\n    \n    # Calculate rows for interval\n    rows_for_interval <- averaging_interval / diff(data$Time[1:2])\n    \n    # Compute the rolling average\n    filtered_data <- filtered_data %>%\n      mutate(rolling_avg = zoo::rollapply(.data[[col_interest]], width = rows_for_interval, FUN = mean, align = \"right\", fill = NA))\n    \n    # Check if rolling_avg contains non-NA values. If all values in rolling_avg are NA, then it returns NA as peak value\n    if (all(is.na(filtered_data$rolling_avg))) {\n      return(NA)\n    }\n    \n    # Find the maximum rolling average\n    peak_value <- filtered_data %>%\n      summarize(max_rolling_avg = max(rolling_avg, na.rm = TRUE)) %>%\n      pull(max_rolling_avg)\n    \n    return(peak_value)\n  }\n  \n  # Calculate peak values for each column of interest\n  peak_values <- cols_interest %>%\n    set_names(paste0(., \"_peak\")) %>%\n    map(~ calculate_peak(data, .x)) %>%\n    as_tibble() %>%\n    select(where(~ !all(is.na(.))))\n  \n  # Calculate the adjusted peak intensity of the file\n  \n  # Adjust end_time based on whether there is a baseline stage\n  if (use_baseline) {\n    adjusted_end_time <- end_time + baseline_length\n  } else {\n    adjusted_end_time <- end_time\n  }\n  \n  # Make new variable, second_highest_speed' that holds the second highest speed\n  second_highest_speed <- data %>%\n    arrange(desc(Speed_kph)) %>%\n    distinct(Speed_kph) %>%\n    slice(2) %>%\n    pull(Speed_kph)\n  \n  # Find the last row corresponding to the second highest speed\n  last_row <- data %>% filter(Speed_kph == second_highest_speed) %>% slice(n())\n  \n  # Calculate the time difference between the end test time and the time associated with the last row corresponding to second highest speed\n  time_diff <- as.numeric(difftime(adjusted_end_time, last_row$Time, units = \"secs\"))\n  \n  # Determine if there are multiple stages in protocol_2\n  has_multiple_protocol_2_stages <- data %>%\n    filter(Protocol == 'protocol_2') %>%\n    summarise(unique_stages = n_distinct(Stage)) %>%\n    pull(unique_stages) > 1\n  \n  # Calculate new adjusted time difference based on conditions\n  if (use_break) {\n    if (use_protocol_2) {\n      if (!has_multiple_protocol_2_stages) {\n        # Adjust time_diff if use_break and use_protocol_2 are TRUE, and protocol_2 has only one stage\n        adjusted_time_diff <- time_diff - break_length\n      } else {\n        # Do not adjust time_diff if protocol_2 has multiple stages\n        adjusted_time_diff <- time_diff\n      }\n    } else {\n      # Adjust time_diff if use_break is TRUE and use_protocol_2 is FALSE\n      adjusted_time_diff <- time_diff - break_length\n    }\n  } else {\n    # Do not adjust time_diff if use_break is FALSE\n    adjusted_time_diff <- time_diff\n  }\n  \n  # Calculate peak intensity based on conditions\n  peak_intensity <- if (use_protocol_2) {\n    second_highest_speed + (adjusted_time_diff / protocol_2_length * protocol_2_increase)\n  } else {\n    second_highest_speed + (adjusted_time_diff / protocol_1_length * protocol_1_increase)\n  }\n  \n  # Combine results into a tibble\n  test_summary <- bind_cols(\n    meta_data,\n    Test_duration = sprintf(\"%d:%02d\", end_time %/% 60, end_time %% 60),\n    V_peak = peak_intensity,\n    peak_values\n  )\n  \n  return(test_summary)\n}\n\n#################################################\n# Assign normative info related to VO2max\nassign_VO2max_norms <- function(\n    athlete_characteristics_df,\n    exercise_mode) {\n  \n  # Define the reference data as a data frame\n  vo2max_reference_data <- data.frame(\n    Sex = c(rep(\"male\", 18), rep(\"female\", 18)),\n    Exercise = c(rep(\"Treadmill\", 9), rep(\"Cycle Ergometer\", 9), rep(\"Treadmill\", 9), rep(\"Cycle Ergometer\", 9)),\n    Percentile = rep(c(90, 80, 70, 60, 50, 40, 30, 20, 10), 4),\n    Age_20_29 = c(58.6, 54.5, 51.9, 49.0, 46.5, 43.6, 40.0, 35.2, 28.6, 62.2, 57.0, 52.8, 48.3, 44.0, 40.8, 37.4, 34.5, 28.8, 49.0, 44.8, 41.8, 39.0, 36.6, 34.0, 30.8, 27.2, 22.5, 46.0, 40.9, 37.5, 34.3, 31.6, 28.9, 25.6, 21.9, 18.8),\n    Age_30_39 = c(55.5, 50.0, 46.4, 43.4, 39.7, 37.0, 33.5, 29.8, 24.9, 50.5, 39.0, 35.5, 31.6, 30.2, 27.9, 25.7, 22.6, 19.1, 42.1, 37.0, 33.6, 31.0, 28.3, 26.4, 24.2, 21.9, 18.6, 32.0, 27.0, 24.5, 22.9, 21.6, 19.9, 18.6, 17.0, 15.0),\n    Age_40_49 = c(50.8, 45.2, 40.9, 37.9, 35.3, 32.4, 29.7, 26.7, 22.1, 41.9, 35.1, 31.4, 29.0, 27.4, 25.4, 23.8, 21.9, 19.8, 37.8, 33.0, 30.0, 27.7, 25.7, 23.9, 21.8, 19.7, 17.2, 27.3, 23.5, 21.8, 20.3, 18.8, 17.9, 16.6, 15.4, 13.7),\n    Age_50_59 = c(43.4, 38.3, 34.3, 31.8, 29.2, 26.9, 24.5, 22.2, 18.6, 37.1, 31.6, 28.4, 26.3, 24.5, 23.1, 22.0, 20.2, 17.2, 32.4, 28.4, 26.3, 24.6, 22.9, 21.5, 20.1, 18.5, 16.5, 22.4, 20.4, 18.9, 17.8, 16.9, 16.1, 15.2, 14.3, 13.0),\n    Age_60_69 = c(37.1, 32.0, 28.7, 26.5, 24.6, 22.8, 20.7, 18.5, 15.8, 31.4, 27.0, 24.5, 23.3, 21.7, 20.7, 19.1, 17.5, 14.7, 27.3, 24.3, 22.4, 20.9, 19.6, 18.3, 17.0, 15.4, 13.4, 20.3, 18.5, 17.4, 16.4, 15.7, 15.0, 14.2, 13.4, 12.2),\n    Age_70_79 = c(29.4, 25.9, 23.8, 22.2, 20.6, 19.1, 17.3, 15.9, 13.6, 26.2, 22.6, 20.6, 19.4, 18.3, 17.1, 16.0, 14.7, 11.0, 22.8, 20.8, 19.6, 18.3, 17.2, 16.2, 15.2, 14.0, 12.3, 18.0, 16.8, 15.9, 15.0, 14.5, 13.6, 12.9, 12.0, 10.7),\n    Age_80_89 = c(22.8, 21.4, 20.0, 18.4, 17.6, 16.6, 16.1, 14.8, 12.9, 18.7, 17.3, 16.2, 14.6, 13.2, 12.2, 11.1, 9.7, 8.4, 20.8, 18.4, 17.3, 16.0, 15.4, 14.7, 13.7, 12.6, 11.4, 18.1, 14.3, 12.9, 11.3, 10.9, 10.1, 9.4, 8.7, 7.8)\n  )\n  \n  # Myers et al., 2017 calculation for VO2max norms\n  VO2max_age_pred <- 79.9 - (0.39 * athlete_characteristics_df$Age) - (13.7 * ifelse(athlete_characteristics_df$Sex == \"female\", 1, 0)) - (0.127 * athlete_characteristics_df$Weight * 2.20462)\n  VO2max_percent_age_pred <- athlete_characteristics_df$VO2kg_peak / VO2max_age_pred * 100\n  \n  # Determine age group\n  age_group <- case_when(\n    athlete_characteristics_df$Age >= 20 & athlete_characteristics_df$Age < 30 ~ 'Age_20_29',\n    athlete_characteristics_df$Age >= 30 & athlete_characteristics_df$Age < 40 ~ 'Age_30_39',\n    athlete_characteristics_df$Age >= 40 & athlete_characteristics_df$Age < 50 ~ 'Age_40_49',\n    athlete_characteristics_df$Age >= 50 & athlete_characteristics_df$Age < 60 ~ 'Age_50_59',\n    athlete_characteristics_df$Age >= 60 & athlete_characteristics_df$Age < 70 ~ 'Age_60_69',\n    athlete_characteristics_df$Age >= 70 & athlete_characteristics_df$Age < 80 ~ 'Age_70_79',\n    athlete_characteristics_df$Age >= 80 & athlete_characteristics_df$Age < 90 ~ 'Age_70_79',\n    TRUE ~ NA_character_\n  )\n  \n  if (!exercise_mode %in% c(\"Treadmill\", \"Cycle Ergometer\")) {\n    percentile <- \"Percentiles not available for the exercise modality\"\n    percentile_desc <- \"Percentiles not available for the exercise modality\"\n  } else if (is.na(age_group)) {\n    percentile <- \"Percentiles not available for the age group\"\n    percentile_desc <- \"Percentiles not available for the age group\"\n  } else {\n    # Filter and select relevant reference standards\n    relevant_standards <- vo2max_reference_data %>%\n      filter(Sex == athlete_characteristics_df$Sex & Exercise == exercise_mode) %>%\n      select(Percentile, all_of(age_group))\n    \n    # Find the percentile corresponding to the athlete's VO2max\n    percentile <- relevant_standards %>%\n      filter(relevant_standards[[age_group]] <= athlete_characteristics_df$VO2kg_peak) %>%\n      arrange(desc(Percentile)) %>%\n      slice(1) %>%\n      pull(Percentile)\n    \n    if (length(percentile) == 0) {\n      percentile <- \"VO2max is below the 5th percentile\"\n      percentile_desc <- \"very poor\"\n    } else {\n      # Assign descriptive category based on the percentile\n      percentile_desc <- case_when(\n        percentile > 80 ~ \"excellent\",\n        percentile >= 60 & percentile < 80 ~ \"good\",\n        percentile >= 40 & percentile < 60 ~ \"fair\",\n        percentile >= 20 & percentile < 40 ~ \"poor\",\n        percentile < 20 ~ \"very poor\"\n      )\n    }\n  }\n  \n  # Combine the results into a tibble\n  test_summary <- bind_cols(\n    athlete_characteristics_df,\n    tibble(\n      VO2max_age_pred = VO2max_age_pred,\n      VO2max_age_pred_percent = VO2max_percent_age_pred,\n      VO2max_percentile = percentile,\n      VO2max_percentile_desc = percentile_desc\n    )\n  )\n  \n  return(test_summary)\n}\n\n\n###################################################\n# Calculate vVO2max\nworkload_at_vo2max <- function(\n    data,\n    summary) {\n  # Filter data for Protocol == \"protocol_1\"\n  filtered_data <- data %>%\n    filter(Protocol == \"protocol_1\")\n  \n  # Perform linear regression with VO2 on the x-axis and Speed_kph on the y-axis\n  lm_model <- lm(Speed_kph ~ VO2, data = filtered_data)\n  \n  # Get the coefficients from the linear model\n  intercept <- coef(lm_model)[1]\n  slope <- coef(lm_model)[2]\n  \n  # Solve the regression equation using the VO2_peak value\n  vVO2max <- intercept + slope * summary$VO2_peak\n  \n  summary$vVO2max <- vVO2max\n  \n  return(summary)\n}\n\n\n\n##################################################################\n# Calculate Fatmax and MFO\ncalculate_fatmax <-function(avg_stage_data,test_summary) {\n  \n  # Filter data so it's only the rows where RER < 1\n  filtered_df <- avg_stage_data %>%\n    filter(RER <= 1)\n  \n  # Fit third-degree polynomial models with intercept set to zero\n  fit_speed <- lm(FAT_gmin ~ 0 + poly(Speed_kph, 3, raw = TRUE), data = filtered_df)\n  fit_hr <- lm(FAT_gmin ~ 0 + poly(Perc_HR_peak, 3, raw = TRUE), data = filtered_df)\n  fit_vo2 <- lm(FAT_gmin ~ 0 + poly(Perc_VO2_peak, 3, raw = TRUE), data = filtered_df)\n  \n  # Create sequences for prediction\n  speed_seq <- seq(min(filtered_df$Speed_kph), max(filtered_df$Speed_kph), length.out = 1000)\n  hr_seq <- seq(min(filtered_df$Perc_HR_peak), max(filtered_df$Perc_HR_peak), length.out = 1000)\n  vo2_seq <- seq(min(filtered_df$Perc_VO2_peak), max(filtered_df$Perc_VO2_peak), length.out = 1000)\n  \n  # Predict FAT_gmin values using the polynomial models\n  pred_speed <- predict(fit_speed, newdata = data.frame(Speed_kph = speed_seq))\n  pred_hr <- predict(fit_hr, newdata = data.frame(Perc_HR_peak = hr_seq))\n  pred_vo2 <- predict(fit_vo2, newdata = data.frame(Perc_VO2_peak = vo2_seq))\n  \n  # Find the values that give the maximum FAT_gmin\n  max_index_speed <- which.max(pred_speed)\n  max_index_hr <- which.max(pred_hr)\n  max_index_vo2 <- which.max(pred_vo2)\n  \n  fatmax_speed <- speed_seq[max_index_speed]\n  fatmax_hr <- hr_seq[max_index_hr]\n  fatmax_vo2 <- vo2_seq[max_index_vo2]\n  \n  max_fat_oxidation_speed <- pred_speed[max_index_speed]\n  max_fat_oxidation_hr <- pred_hr[max_index_hr]\n  max_fat_oxidation_vo2 <- pred_vo2[max_index_vo2]\n  \n  # Update test_summary with new values\n  test_summary <- test_summary %>%\n    mutate(\n      Fatmax_kph = fatmax_speed,\n      Fatmax_HR = fatmax_hr,\n      Fatmax_VO2 = fatmax_vo2,\n      MFO_gmin = max_fat_oxidation_speed)\n  \n  return(test_summary)\n}\n\n\n\n############################################################################\n## Miscellaneous functions ===================================\n\n# Convert time in m:ss to seconds\nconvert_to_s <- function(time_str) {\n  \n  Time = lubridate::period_to_seconds(lubridate::ms(time_str, roll = TRUE))\n  return(Time)\n}\n\n############################################################\n# Add % HRpeak and VO2peak columns to avg_stage_data\nadd_peak_percentages <- function(avg_stage_data,test_summary) {\n  \n  HR_peak <- pull(test_summary, HR_peak)\n  VO2_peak <- pull(test_summary, VO2_peak)\n  \n  avg_stage_data <- avg_stage_data %>%\n    mutate(Perc_HR_peak = HR/HR_peak * 100,\n           Perc_VO2_peak = VO2/VO2_peak * 100)\n  \n  return(avg_stage_data)\n}\n\n\n#######################################################################################\n# Delete the rounded 'Time' column and mutate a minute decimal time column in the df\nfix_time <- function(data) {\n  \n  data <- data %>%\n    select(-Time) %>%\n    mutate(Time_m = Time_s / 60) %>%\n    relocate(Time_m, .after = Time_mss)\n  \n  return(data)\n}\n\n\n#####################################################\n# adjust parvo_eg_data based on exercise modality\nadjust_to_modality_parvo_eg_data <- function(parvo_eg_data,test_summary,exercise_mode,power_unit) {\n  \n  if (exercise_mode %in% c(\"Cycle Ergometer\", \"Rowing Ergometer\")) {\n    parvo_eg_data <- parvo_eg_data %>%\n      select(-Speed_minkm,\n             -Speed_minkm_dec) %>%\n      rename(Power_W = Speed_kph)\n    \n    if (power_unit) {\n      parvo_eg_data <- parvo_eg_data %>%\n        mutate(Power_W_temp = Power_W * test_summary$Weight) %>%\n        relocate(Power_W_temp, .before = Power_W) %>%\n        rename(Power_Wkg = Power_W, Power_W = Power_W_temp)\n    } else {\n      parvo_eg_data <- parvo_eg_data %>%\n        mutate(Power_Wkg = Power_W / test_summary$Weight) %>%\n        relocate(Power_Wkg, .after = Power_W)\n    }\n  }\n  \n  return(parvo_eg_data)\n}\n\n\n#######################################################################\n# adjust avg_stage_data based on exercise modality\nadjust_to_modality_avg_stage_data <- function(avg_stage_data,test_summary,exercise_mode,power_unit) {\n  \n  add_avg_cycling_metrics <- function(avg_stage_data, test_summary, power_unit) {\n    \n    if (power_unit) {\n      avg_stage_data <- avg_stage_data %>%\n        mutate(\n          CE_LminW = VO2 / (Power_W * test_summary$Weight),\n          # Used by Lucia, 2002; Millet, 2003; Coyle, 1991 - did they have the units wrong?? Look at Table 4 of Coyle 1991\n          CE_WLmin = (Power_W * test_summary$Weight) / VO2,\n          # Used by Moseley & Jeukendrup, 2000\n          CE_kJL = (Power_W * test_summary$Weight) / VO2 * 60 / 1000,\n          # Calculated as ratio of work rate (W) to energy expended (J/s); Moseley & Jeukendrup, 2000\n          GE_Js = (Power_W * test_summary$Weight) / P_Js * 100,\n          # Calculated as ratio of work rate (kcal/min) to energy expended (kcal/min); Coyle, 1991\n          # Is 60/4184 correct conversion? Based on 4.184 J = 1 cal?\n          GE_kcalmin = ((Power_W * test_summary$Weight) * 60 / 4184) / EE_kcalmin * 100) %>%\n        relocate(CE_LminW, CE_WLmin, CE_kJL, GE_Js, GE_kcalmin, .before = Power_W)\n    } else {\n      avg_stage_data <- avg_stage_data %>%\n        mutate(\n          CE_LminW = VO2 / Power_W,\n          CE_WLmin = Power_W / VO2,\n          CE_kJL = Power_W / VO2 * 60 / 1000,\n          GE_Js = Power_W / P_Js * 100,\n          GE_kcalmin = (Power_W * 60 / 4184) / EE_kcalmin * 100) %>%\n        relocate(CE_LminW, CE_WLmin, CE_kJL, GE_Js, GE_kcalmin, .before = Power_W)\n    }\n    \n    return(avg_stage_data)\n  }\n  \n  if (exercise_mode %in% c(\"Cycle Ergometer\", \"Rowing Ergometer\")) {\n    avg_stage_data <- avg_stage_data %>%\n      select(-Speed_minkm,\n             -Speed_minkm_dec,\n             -RE_mlkgkm,\n             -RE_kcalkm,\n             -RE_kcalkgkm) %>%\n      rename(Power_W = Speed_kph)\n    \n    avg_stage_data <- add_avg_cycling_metrics(avg_stage_data, test_summary, power_unit)\n    \n    if (power_unit) {\n      avg_stage_data <- avg_stage_data %>%\n        mutate(Power_W_temp = Power_W * test_summary$Weight) %>%\n        relocate(Power_W_temp, .before = Power_W) %>%\n        rename(Power_Wkg = Power_W, Power_W = Power_W_temp)\n    } else {\n      avg_stage_data <- avg_stage_data %>%\n        mutate(Power_Wkg = Power_W / test_summary$Weight) %>%\n        relocate(Power_Wkg, .after = Power_W)\n    }\n  }\n  \n  return(avg_stage_data)\n  \n}\n\n\n\n#########################################################\n# adjust test_summary based on exercise modality\nadjust_to_modality_test_summary <- function(test_summary,exercise_mode,power_unit) {\n  \n  if (exercise_mode %in% c(\"Cycle Ergometer\", \"Rowing Ergometer\")) {\n    test_summary <- test_summary %>%\n      rename(pVO2max = vVO2max,\n             W_peak = V_peak,\n             Fatmax_W = Fatmax_kph)# %>%\n    # add delta efficiency code here\n    \n    if (power_unit) {\n      test_summary <- test_summary %>%\n        mutate(pVO2max_W_temp = pVO2max * Weight,\n               W_peak_temp = W_peak * Weight,\n               Fatmax_W_temp = Fatmax_W * Weight) %>%\n        relocate(pVO2max_W_temp, .before = pVO2max) %>%\n        relocate(W_peak_temp, .before = W_peak) %>%\n        relocate(Fatmax_W_temp, .before = Fatmax_W) %>%\n        rename(pVO2max_Wkg = pVO2max, pVO2max_W = pVO2max_W_temp,\n               Wkg_peak = W_peak, W_peak = W_peak_temp,\n               Fatmax_Wkg = Fatmax_W, Fatmax_W = Fatmax_W_temp)\n    } else {\n      test_summary <- test_summary %>%\n        mutate(pVO2max_Wkg = pVO2max / Weight,\n               Wkg_peak = W_peak / Weight,\n               Fatmax_Wkg = Fatmax_W / Weight) %>%\n        relocate(pVO2max_Wkg, .after = pVO2max) %>%\n        rename(pVO2max_W = pVO2max) %>%\n        relocate(Wkg_peak, .after = W_peak) %>%\n        relocate(Fatmax_Wkg, .after = Fatmax_W)\n    }\n  }\n  \n  return(test_summary)\n  \n}\n\n\n\n############################################################\n# Add thresholds and zone info to test_summary\nadd_threshold_zone <- function(threshold_zone_info,test_summary) {\n  \n  threshold_zone <- threshold_zone_info()\n  \n  for (col in names(threshold_zone)) {\n    if (!all(is.na(threshold_zone[[col]]))) {\n      test_summary[[col]] <- threshold_zone[[col]]\n    }\n  }\n  \n  return(test_summary)\n  \n}\n\n# # Add marathon race prediction times to test_summary\n# add_race_prediction <-\n#   function(\n    #     exercise_mode,\n#     test_summary\n#   ) {\n#     \n#     if (exercise_mode == \"Treadmill\") {\n#       test_summary$\n#     }\n#     \n#     return(test_summary)\n#     \n#   }\n\n#############################################################\n# Remove empty columns\n# remove_empty_columns <- function(df){\n#   \n#   # Remove columns where all values are NA or empty\n#   df_cleaned <- df[, colSums(!is.na(df) & df != \"\") > 0]\n#   \n#   return(df_cleaned)\n# }\n\n","type":"text"},{"name":"app_ORIG.R","content":"### SETUP ====================================================\n\n# Reading libraries\nsuppressPackageStartupMessages({\n  library(shiny)\n  library(shinydashboard)\n  library(shinyWidgets)\n  library(readxl)\n  library(writexl)\n  library(fuzzyjoin)\n  library(tidyverse)\n  library(rhandsontable)\n  library(SimplyAgree)\n  library(zoo)\n  library(plotly)\n  library(fresh)\n})\n\n# Setting global options \noptions(digits = 5, digits.secs = 3, scipen = 3,\n        dplyr.summarise.inform = FALSE)\n\n### CREATING FUNCTIONS FOR PROCESSING ========================\n## Data Wrangling ============================================\n\n# Create parvo_data list with 2 df (parvo_metadata and parvo_eg_data)\n# Add some variables of interest\nparvo_process <- \n  function(\n    parvo_data_raw,\n    col_names = c(\n      \"Time\", \"VO2\", \"VO2kg\", \"VCO2\",\n      \"RER\", \"RR\", \"VT\", \"VE\", \"VEVO2\", \"VEVCO2\",\n      \"FEO2\", \"FECO2\", \"HR\")\n  ) {\n    \n    # Ensures the raw Parvo export file has all the variables of interest in the expired gas section\n    variables_of_interest_row <- which(grepl(\"---------\", parvo_data_raw[[1]]))\n    \n    required_variables <- c(\"TIME\", \"VO2\", \"VO2/kg\", \"VCO2\", \"RER\", \"RR\", \"Vt\", \"VE\", \"VE/\", \"VE/\", \"FEO2\", \"FECO2\", \"HR\")\n    if (variables_of_interest_row - 3 < 1 || !identical(required_variables, as.character(parvo_data_raw[variables_of_interest_row - 3, ]))) {\n      stop(\"Error: The required expired gas variables of interest are not found or do not match the expected order.\")\n    }\n    \n    # Ensures the first cell below \"---------\" contains a colon, which is used to assume time is exported in m:ss (and not in minute decimal format)\n    if (!grepl(\":\", parvo_data_raw[variables_of_interest_row + 1, 1])) {\n      stop(\"Error: Please export the Time column in 'm:ss' format.\")\n    }\n    \n    parvo_eg_data <- parvo_data_raw %>%\n      # remove metadata details so you only have df if expired gas data\n      slice_tail(n = -which(grepl(\"---------\", parvo_data_raw[[1]]))) %>% \n      # rename columns from col_names input\n      rename_with(~ col_names) %>% \n      # remove footer (Max, Events, and Summary) details, starting with first NA row in Time column\n      slice(-(head(which(is.na(Time)),1):nrow(.))) %>%\n      # convert all but Time column to numeric\n      mutate(across(-Time, ~ as.numeric(.))) %>% \n      # hide warnings when reading mixed data types\n      suppressWarnings() %>%\n      # create new Time column in seconds\n      mutate(Time_mss = Time) %>%\n      relocate(Time_mss, .before = Time) %>%\n      mutate(Time = lubridate::period_to_seconds(lubridate::ms(Time, roll = TRUE))) %>%\n      \n      # filter erroneous data where VO2 or VT below empirical cutoff. will keep the row of data, but replaces all the data with NA\n      mutate(\n        across(-c(Time, matches(\"Time_mss\")), ~ case_when(\n          VO2 < 0.1 | VT < 0.1 ~ NA_real_,\n          TRUE ~ .)),\n      ) %>%\n      \n      # create columns with additional variables of interest\n      mutate(\n        # substrate oxidation in g/min (VO2 & VCO2 in L/min), from Peronnet & Massicotte, 1991\n        CHO_gmin = 4.585 * VCO2 - 3.226 * VO2,\n        FAT_gmin = 1.695 * VO2 - 1.701 * VCO2,\n        # Jeukendrup & Wallis, 2005 (50-75% Intensity)\n        # Double check with Trent if go with 9 and 4 kcal/g\n        CHO_kcalmin = CHO_gmin * 4,\n        FAT_kcalmin = FAT_gmin * 9,\n        Total_kcalmin = FAT_kcalmin + CHO_kcalmin,\n        Total_kcalhr = Total_kcalmin * 60,\n        # calculate O2eq in kJ/L & kcal/L, from Péronnet & Massicotte, 1991\n        O2_kJL = 16.8835 + 4.8353 * pmin(pmax(RER, 0.7036), 0.9961),\n        O2_kcalL = 4.0372 + 1.1563 * pmin(pmax(RER, 0.7036), 0.9961),\n        # Aerobic Work Expenditure in kJ/min (VO2 in L/min, O2kJ in kJ/L)\n        WE_kJmin = VO2 * O2_kJL,\n        # Aerobic Power in W = J/sec (VO2 in L/min, O2kJ in kJ/L)\n        P_Js = VO2 * O2_kJL * 1000/60,\n        # Aerobic Energy Expenditure in kcal/min (VO2 in L/min, O2kcal in kcal/L)\n        EE_kcalmin = VO2 * O2_kcalL\n      )\n    \n    # create df with test metadata\n    parvo_metadata <- \n      tibble(\n        Name = as.character(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Name\", .)))[[which(grepl(\"Name\", parvo_data_raw)) + 1]]),\n        Test_Date = as.character(paste(parvo_data_raw[2, 2], sprintf(\"%02d\", as.numeric(parvo_data_raw[2, 4])), sprintf(\"%02d\", as.numeric(parvo_data_raw[2, 6])), sep = \"/\")),\n        Test_Time = paste(paste(parvo_data_raw[2, 7:9], collapse = \"\"), parvo_data_raw[2, 10], sep = \":\"),\n        Age = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Age\", .)))[[which(grepl(\"Age\", parvo_data_raw)) + 1]]),\n        Sex = case_when(\n          grepl(\"F\", filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Sex\", .)))[[which(grepl(\"Sex\", parvo_data_raw)) + 1]]) ~ \"female\",\n          grepl(\"M\", filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Sex\", .)))[[which(grepl(\"Sex\", parvo_data_raw)) + 1]]) ~ \"male\"),\n        Height = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Height\", .)))[[which(grepl(\"Height\", parvo_data_raw)) + 3]]),\n        Weight = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Weight\", .)))[[which(grepl(\"Weight\", parvo_data_raw)) + 3]]),\n        BMI = round(Weight / (Height/100)^2 , 2),\n        Temperature = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Insp. temp\", .)))[[which(grepl(\"Insp. temp\", parvo_data_raw)) + 1]]),\n        RH = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Insp. humidity\", .)))[[which(grepl(\"Insp. humidity\", parvo_data_raw)) + 1]])\n      )\n    \n    return(list(parvo_eg_data = parvo_eg_data, parvo_metadata = parvo_metadata))\n  }\n\n# Remove all rows that exceed the end of the test\nremove_post_test_rows <-\n  function(\n    data,\n    input_time,\n    use_baseline,\n    baseline_length\n  ) {\n    \n    # Adjust the input_time if there is a baseline stage\n    if (use_baseline) {\n      input_time <- input_time + baseline_length\n    }\n    \n    # Find the index of the maximum value where Time is less than or equal to input_time\n    closest_index <- which.max(data$Time[data$Time <= input_time])\n    \n    # Check if there's an exact match\n    if (any(data$Time == input_time)) {\n      # If an exact match is found, get its index\n      exact_match_index <- which(data$Time == input_time)[1]\n      # Keep rows up to and including the exact match\n      result_data <- data[1:exact_match_index, ]\n    } else {\n      # If no exact match, find the closest preceding time and include the first row after it\n      if (length(closest_index) == 0) {\n        # Handle case when all times are greater than input_time\n        result_data <- data\n      } else {\n        # Ensure we do not exceed the bounds of the dataframe\n        end_index <- min(closest_index + 1, nrow(data))\n        result_data <- data[1:end_index, ]\n      }\n    }\n    \n    return(result_data)\n  }\n\n# Round time to make it easier to work with\nreplace_with_closest_multiple <-\n  function(\n    data\n  ) {\n    # Creates a new column to \"store\" the original \"Time\" values\n    data <- data %>%\n      mutate(Time_s = Time, .before = Time)\n    \n    # Replace the values with rounded \"Time\" values\n    rounded_diff <- round(mean(diff(data$Time)))\n    data$Time <- round(data$Time / rounded_diff) * rounded_diff\n    return(data)\n  }\n\n# Add \"Speed\", \"Protocol\", and \"Stage\" columns\nassign_intensity <-\n  function(\n    data, protocol_1_start, protocol_1_increase, protocol_1_length,\n    use_baseline = FALSE, baseline_length = 0, baseline_intensity = 0,\n    use_protocol_2 = FALSE, time_of_change = 0, protocol_2_start = 0, protocol_2_increase = 0, protocol_2_length = 0,\n    use_break = FALSE, break_length = 0, break_speed = 0\n  ) {\n    \n    # adjust protocol_1_length so it either includes or doesn't include break_length, and also + 0.1 to ensure calculations do not exclude any required time period.\n    adjusted_protocol_1_length <- ifelse(use_break, protocol_1_length + break_length + 0.1, protocol_1_length + 0.1)\n    \n    # adjust time_of_change (when protocol_1 transitions to protocol_2) so that it only includes the first row after the time_of_change \n    adjusted_time_of_change <- time_of_change + 0.1\n    \n    if (use_baseline) {\n      adjusted_time_of_change <- adjusted_time_of_change + baseline_length\n    }\n    \n    # assign \"Speed\" column, with toggles for baseline, breaks, and change in step parameters\n    data <- data %>%\n      mutate(Speed = case_when(\n        use_baseline & Time <= baseline_length ~ baseline_intensity,\n        !use_protocol_2 | (use_protocol_2 & Time <= adjusted_time_of_change) ~ protocol_1_start + protocol_1_increase * ((Time - ifelse(use_baseline, baseline_length, 0)) %/% adjusted_protocol_1_length),\n        use_protocol_2 & Time > adjusted_time_of_change ~ protocol_2_start + protocol_2_increase * ((Time - adjusted_time_of_change) %/% protocol_2_length)\n      )) %>%\n      \n      # assign \"Protocol\" column, with toggles for baseline and change in step parameters\n      mutate(Protocol = case_when(\n        !(use_baseline | use_protocol_2) ~ \"protocol_1\",\n        use_baseline & !use_protocol_2 ~ ifelse(Time <= baseline_length, \"baseline\", \"protocol_1\"),\n        !use_baseline & use_protocol_2 ~ ifelse(Time > adjusted_time_of_change, \"protocol_2\", \"protocol_1\"),\n        use_baseline & use_protocol_2 ~ case_when(\n          Time <= baseline_length ~ \"baseline\",\n          Time <= adjusted_time_of_change ~ \"protocol_1\",\n          TRUE ~ \"protocol_2\"\n        )\n      )) %>%\n      \n      # assign \"Stage\" column based on rank, with - 1 to make sure it always starts at \"Stage_0\"\n      mutate(Stage = paste0(\"Stage_\", dense_rank(Speed) - 1))\n    \n    # adjust \"Speed\" column based on whether there are breaks\n    if (use_break) {\n      data <- data %>%\n        group_by(Stage) %>%\n        mutate(max_time = max(Time),\n               total_stage_time = max_time - min(Time) + mean(diff(Time)),\n               Speed = if_else((Protocol == \"protocol_1\") & (total_stage_time == adjusted_protocol_1_length - 0.1) & (Time > (max_time - break_length)), break_speed, Speed)) %>%\n        ungroup() %>%\n        select(-max_time, -total_stage_time)\n    }\n    \n    # adjust \"Protocol\" column so it starts at \"Stage_1\" if no baseline\n    if (data$Protocol[1] == \"protocol_1\") {\n      data <- data %>%\n        mutate(Stage = str_replace(Stage, \"(\\\\d+)$\", function(x) as.character(as.numeric(x) + 1)))\n    }\n    \n    # adjust \"Protocol\" column so all \"Stage_0\" are replaced with \"baseline\"\n    data <- data %>%\n      mutate(Stage = str_replace_all(Stage, \"Stage_0\", \"baseline\"))\n    \n    # add in min/km and m:ss, and rename Speed to Speed_kph\n    data <- data %>%\n      mutate(Speed_minkm_dec = if_else(Speed == 0, NA_real_, 60 / Speed),\n             Speed_minkm = if_else(\n               is.na(Speed_minkm_dec),\n               NA_character_,\n               sprintf(\"%d:%02d\", floor(Speed_minkm_dec), round((Speed_minkm_dec %% 1) * 60)))) %>%\n      rename(Speed_kph = Speed) %>%\n      relocate(Speed_minkm, Speed_minkm_dec, .after = Speed_kph)\n    \n    return(data)\n  }\n\n# Assign \"Grade/Cadence\", \"Lactate\", and \"RPE\" columns from Shiny manually inputted table\nassign_written_info <-\n  function(\n    data,\n    stage_info,\n    exercise_mode\n  ) {\n    \n    stage_info <- stage_info()\n    \n    # Determine the column name based on the exercise_mode\n    # col_name <- if (exercise_mode == \"Cycle Ergometer\") \"Cadence\" else \"Grade\"\n    \n    col_name <- switch(exercise_mode,\n                       \"Cycle Ergometer\" = \"Cadence\",\n                       \"Rowing Ergometer\" = \"Stroke_Rate\",\n                       \"Grade\")\n    \n    # Match stages and assign Grade/Cadence, Lactate, and RPE values\n    data <- data %>%\n      mutate(\n        !!col_name := stage_info[[col_name]][match(Stage, stage_info$Stage)],\n        Lactate = stage_info$Lactate[match(Stage, stage_info$Stage)],\n        RPE = stage_info$RPE[match(Stage, stage_info$Stage)]\n      )\n    \n    return(data)\n  }\n\n## Creating average stage data file ==========================\n\n# Create the initial average stage df\n# Function will not try to average the columns listed\nprocess_stage_avgs <-\n  function(\n    data,\n    averaging_interval,\n    include_last_row,\n    columns_to_exclude = c(\n      \"Time_mss\", \"Time_s\", \"Time\",\n      \"Speed_minkm\", \"Speed_minkm_dec\", \"Protocol\",\n      \"Stage\", \"Lactate\", \"RPE\",\n      \"Grade\", \"Cadence\", \"Stroke_Rate\")\n  ) {\n    \n    # Exclude rows with 0 Speed or \"baseline\" Stage\n    filtered_data <- data %>%\n      filter(Speed_kph != 0 & Stage != \"baseline\")\n    \n    # Calculate the number of rows for the averaging interval based on the Time column\n    rows_for_interval <- averaging_interval / diff(head(filtered_data$Time, 2))\n    \n    # Group by Speed_kph and calculate the average for all columns except excluded ones\n    avg_data <- filtered_data %>%\n      group_by(Speed_kph) %>%\n      mutate(across(!any_of(columns_to_exclude),\n                    ~ rollapplyr(.x, rows_for_interval, mean, align = \"right\", fill = NA))) %>%\n      filter(!is.na(VO2)) %>%\n      ungroup()\n    \n    # Extract the appropriate row based on include_last_row\n    final_data <- avg_data %>%\n      group_by(Speed_kph) %>%\n      slice(if (include_last_row) n() else if (any(Protocol == 'protocol_1')) n() - 1 else n()) %>%\n      distinct(Speed_kph, .keep_all = TRUE) %>%\n      ungroup()\n    \n    return(final_data)\n  }\n\n# Add running economy and metabolic power variables of interest\nadd_re_mp <-\n  function(\n    data,\n    athlete_df\n  ) {\n    \n    re_mp_data <- data %>%\n      mutate(\n        # calculate metabolic power in kJ/s using Peronnet and Massicotte equation\n        MP_kJs = (16.89 * VO2 / 60) + (4.84 * VCO2 / 60),\n        # expressing metabolic power as W/kg\n        MP_Wkg = MP_kJs / athlete_df$Weight * 1000,\n        # calculate running economy in ml/kg/km\n        RE_mlkgkm = VO2kg * Speed_minkm_dec,\n        # calculate running economy in kcal/km\n        RE_kcalkm = Total_kcalmin * Speed_minkm_dec,\n        # calculate running economy in kcal/kg/km\n        RE_kcalkgkm = RE_kcalkm / athlete_df$Weight) %>%\n      relocate(RE_mlkgkm, RE_kcalkm, RE_kcalkgkm, MP_kJs, MP_Wkg, .before = Speed_kph)\n    \n    return(re_mp_data)\n  }\n\n## Calculate test summary level variables of interest ===========\n\n# Determine peak values for variables of interest and generate test_summary df\nprocess_peak_data <-\n  function(\n    data, meta_data, averaging_interval, cols_interest, end_time, \n    protocol_1_increase, protocol_1_length,\n    use_break, break_length, \n    use_protocol_2, protocol_2_increase, protocol_2_length,\n    use_baseline, baseline_length\n  ) {\n    \n    # Helper function to calculate peak values for a column\n    calculate_peak <- function(data, col_interest) {\n      \n      # Filter data\n      filtered_data <- data %>% filter(Speed_kph != 0 & Stage != \"baseline\")\n      \n      # Calculate rows for interval\n      rows_for_interval <- averaging_interval / diff(data$Time[1:2])\n      \n      # Compute the rolling average\n      filtered_data <- filtered_data %>%\n        mutate(rolling_avg = zoo::rollapply(.data[[col_interest]], width = rows_for_interval, FUN = mean, align = \"right\", fill = NA))\n      \n      # Check if rolling_avg contains non-NA values. If all values in rolling_avg are NA, then it returns NA as peak value\n      if (all(is.na(filtered_data$rolling_avg))) {\n        return(NA)\n      }\n      \n      # Find the maximum rolling average\n      peak_value <- filtered_data %>%\n        summarize(max_rolling_avg = max(rolling_avg, na.rm = TRUE)) %>%\n        pull(max_rolling_avg)\n      \n      return(peak_value)\n    }\n    \n    # Calculate peak values for each column of interest\n    peak_values <- cols_interest %>%\n      set_names(paste0(., \"_peak\")) %>%\n      map(~ calculate_peak(data, .x)) %>%\n      as_tibble() %>%\n      select(where(~ !all(is.na(.))))\n    \n    # Calculate the adjusted peak intensity of the file\n    \n    # Adjust end_time based on whether there is a baseline stage\n    if (use_baseline) {\n      adjusted_end_time <- end_time + baseline_length\n    } else {\n      adjusted_end_time <- end_time\n    }\n    \n    # Make new variable, second_highest_speed' that holds the second highest speed\n    second_highest_speed <- data %>%\n      arrange(desc(Speed_kph)) %>%\n      distinct(Speed_kph) %>%\n      slice(2) %>%\n      pull(Speed_kph)\n    \n    # Find the last row corresponding to the second highest speed\n    last_row <- data %>% filter(Speed_kph == second_highest_speed) %>% slice(n())\n    \n    # Calculate the time difference between the end test time and the time associated with the last row corresponding to second highest speed\n    time_diff <- as.numeric(difftime(adjusted_end_time, last_row$Time, units = \"secs\"))\n    \n    # Determine if there are multiple stages in protocol_2\n    has_multiple_protocol_2_stages <- data %>%\n      filter(Protocol == 'protocol_2') %>%\n      summarise(unique_stages = n_distinct(Stage)) %>%\n      pull(unique_stages) > 1\n    \n    # Calculate new adjusted time difference based on conditions\n    if (use_break) {\n      if (use_protocol_2) {\n        if (!has_multiple_protocol_2_stages) {\n          # Adjust time_diff if use_break and use_protocol_2 are TRUE, and protocol_2 has only one stage\n          adjusted_time_diff <- time_diff - break_length\n        } else {\n          # Do not adjust time_diff if protocol_2 has multiple stages\n          adjusted_time_diff <- time_diff\n        }\n      } else {\n        # Adjust time_diff if use_break is TRUE and use_protocol_2 is FALSE\n        adjusted_time_diff <- time_diff - break_length\n      }\n    } else {\n      # Do not adjust time_diff if use_break is FALSE\n      adjusted_time_diff <- time_diff\n    }\n    \n    # Calculate peak intensity based on conditions\n    peak_intensity <- if (use_protocol_2) {\n      second_highest_speed + (adjusted_time_diff / protocol_2_length * protocol_2_increase)\n    } else {\n      second_highest_speed + (adjusted_time_diff / protocol_1_length * protocol_1_increase)\n    }\n    \n    # Combine results into a tibble\n    test_summary <- bind_cols(\n      meta_data,\n      Test_duration = sprintf(\"%d:%02d\", end_time %/% 60, end_time %% 60),\n      V_peak = peak_intensity,\n      peak_values\n    )\n    \n    return(test_summary)\n  }\n\n# Assign normative info related to VO2max\nassign_VO2max_norms <-\n  function(\n    athlete_characteristics_df,\n    exercise_mode\n  ) {\n    \n    # Define the reference data as a data frame\n    vo2max_reference_data <- data.frame(\n      Sex = c(rep(\"male\", 18), rep(\"female\", 18)),\n      Exercise = c(rep(\"Treadmill\", 9), rep(\"Cycle Ergometer\", 9), rep(\"Treadmill\", 9), rep(\"Cycle Ergometer\", 9)),\n      Percentile = rep(c(90, 80, 70, 60, 50, 40, 30, 20, 10), 4),\n      Age_20_29 = c(58.6, 54.5, 51.9, 49.0, 46.5, 43.6, 40.0, 35.2, 28.6, 62.2, 57.0, 52.8, 48.3, 44.0, 40.8, 37.4, 34.5, 28.8, 49.0, 44.8, 41.8, 39.0, 36.6, 34.0, 30.8, 27.2, 22.5, 46.0, 40.9, 37.5, 34.3, 31.6, 28.9, 25.6, 21.9, 18.8),\n      Age_30_39 = c(55.5, 50.0, 46.4, 43.4, 39.7, 37.0, 33.5, 29.8, 24.9, 50.5, 39.0, 35.5, 31.6, 30.2, 27.9, 25.7, 22.6, 19.1, 42.1, 37.0, 33.6, 31.0, 28.3, 26.4, 24.2, 21.9, 18.6, 32.0, 27.0, 24.5, 22.9, 21.6, 19.9, 18.6, 17.0, 15.0),\n      Age_40_49 = c(50.8, 45.2, 40.9, 37.9, 35.3, 32.4, 29.7, 26.7, 22.1, 41.9, 35.1, 31.4, 29.0, 27.4, 25.4, 23.8, 21.9, 19.8, 37.8, 33.0, 30.0, 27.7, 25.7, 23.9, 21.8, 19.7, 17.2, 27.3, 23.5, 21.8, 20.3, 18.8, 17.9, 16.6, 15.4, 13.7),\n      Age_50_59 = c(43.4, 38.3, 34.3, 31.8, 29.2, 26.9, 24.5, 22.2, 18.6, 37.1, 31.6, 28.4, 26.3, 24.5, 23.1, 22.0, 20.2, 17.2, 32.4, 28.4, 26.3, 24.6, 22.9, 21.5, 20.1, 18.5, 16.5, 22.4, 20.4, 18.9, 17.8, 16.9, 16.1, 15.2, 14.3, 13.0),\n      Age_60_69 = c(37.1, 32.0, 28.7, 26.5, 24.6, 22.8, 20.7, 18.5, 15.8, 31.4, 27.0, 24.5, 23.3, 21.7, 20.7, 19.1, 17.5, 14.7, 27.3, 24.3, 22.4, 20.9, 19.6, 18.3, 17.0, 15.4, 13.4, 20.3, 18.5, 17.4, 16.4, 15.7, 15.0, 14.2, 13.4, 12.2),\n      Age_70_79 = c(29.4, 25.9, 23.8, 22.2, 20.6, 19.1, 17.3, 15.9, 13.6, 26.2, 22.6, 20.6, 19.4, 18.3, 17.1, 16.0, 14.7, 11.0, 22.8, 20.8, 19.6, 18.3, 17.2, 16.2, 15.2, 14.0, 12.3, 18.0, 16.8, 15.9, 15.0, 14.5, 13.6, 12.9, 12.0, 10.7),\n      Age_80_89 = c(22.8, 21.4, 20.0, 18.4, 17.6, 16.6, 16.1, 14.8, 12.9, 18.7, 17.3, 16.2, 14.6, 13.2, 12.2, 11.1, 9.7, 8.4, 20.8, 18.4, 17.3, 16.0, 15.4, 14.7, 13.7, 12.6, 11.4, 18.1, 14.3, 12.9, 11.3, 10.9, 10.1, 9.4, 8.7, 7.8)\n    )\n    \n    # Myers et al., 2017 calculation for VO2max norms\n    VO2max_age_pred <- 79.9 - (0.39 * athlete_characteristics_df$Age) - (13.7 * ifelse(athlete_characteristics_df$Sex == \"female\", 1, 0)) - (0.127 * athlete_characteristics_df$Weight * 2.20462)\n    VO2max_percent_age_pred <- athlete_characteristics_df$VO2kg_peak / VO2max_age_pred * 100\n    \n    # Determine age group\n    age_group <- case_when(\n      athlete_characteristics_df$Age >= 20 & athlete_characteristics_df$Age < 30 ~ 'Age_20_29',\n      athlete_characteristics_df$Age >= 30 & athlete_characteristics_df$Age < 40 ~ 'Age_30_39',\n      athlete_characteristics_df$Age >= 40 & athlete_characteristics_df$Age < 50 ~ 'Age_40_49',\n      athlete_characteristics_df$Age >= 50 & athlete_characteristics_df$Age < 60 ~ 'Age_50_59',\n      athlete_characteristics_df$Age >= 60 & athlete_characteristics_df$Age < 70 ~ 'Age_60_69',\n      athlete_characteristics_df$Age >= 70 & athlete_characteristics_df$Age < 80 ~ 'Age_70_79',\n      athlete_characteristics_df$Age >= 80 & athlete_characteristics_df$Age < 90 ~ 'Age_70_79',\n      TRUE ~ NA_character_\n    )\n    \n    if (!exercise_mode %in% c(\"Treadmill\", \"Cycle Ergometer\")) {\n      percentile <- \"Percentiles not available for the exercise modality\"\n      percentile_desc <- \"Percentiles not available for the exercise modality\"\n    } else if (is.na(age_group)) {\n      percentile <- \"Percentiles not available for the age group\"\n      percentile_desc <- \"Percentiles not available for the age group\"\n    } else {\n      # Filter and select relevant reference standards\n      relevant_standards <- vo2max_reference_data %>%\n        filter(Sex == athlete_characteristics_df$Sex & Exercise == exercise_mode) %>%\n        select(Percentile, all_of(age_group))\n      \n      # Find the percentile corresponding to the athlete's VO2max\n      percentile <- relevant_standards %>%\n        filter(relevant_standards[[age_group]] <= athlete_characteristics_df$VO2kg_peak) %>%\n        arrange(desc(Percentile)) %>%\n        slice(1) %>%\n        pull(Percentile)\n      \n      if (length(percentile) == 0) {\n        percentile <- \"VO2max is below the 5th percentile\"\n        percentile_desc <- \"very poor\"\n      } else {\n        # Assign descriptive category based on the percentile\n        percentile_desc <- case_when(\n          percentile > 80 ~ \"excellent\",\n          percentile >= 60 & percentile < 80 ~ \"good\",\n          percentile >= 40 & percentile < 60 ~ \"fair\",\n          percentile >= 20 & percentile < 40 ~ \"poor\",\n          percentile < 20 ~ \"very poor\"\n        )\n      }\n    }\n    \n    # Combine the results into a tibble\n    test_summary <- bind_cols(\n      athlete_characteristics_df,\n      tibble(\n        VO2max_age_pred = VO2max_age_pred,\n        VO2max_age_pred_percent = VO2max_percent_age_pred,\n        VO2max_percentile = percentile,\n        VO2max_percentile_desc = percentile_desc\n      )\n    )\n    \n    return(test_summary)\n  }\n\n# Calculate vVO2max\nworkload_at_vo2max <-\n  function(\n    data,\n    summary\n  ) {\n    # Filter data for Protocol == \"protocol_1\"\n    filtered_data <- data %>%\n      filter(Protocol == \"protocol_1\")\n    \n    # Perform linear regression with VO2 on the x-axis and Speed_kph on the y-axis\n    lm_model <- lm(Speed_kph ~ VO2, data = filtered_data)\n    \n    # Get the coefficients from the linear model\n    intercept <- coef(lm_model)[1]\n    slope <- coef(lm_model)[2]\n    \n    # Solve the regression equation using the VO2_peak value\n    vVO2max <- intercept + slope * summary$VO2_peak\n    \n    summary$vVO2max <- vVO2max\n    \n    return(summary)\n  }\n\n# Calculate Fatmax and MFO\ncalculate_fatmax <-\n  function(\n    avg_stage_data,\n    test_summary\n  ) {\n    \n    # Filter data so it's only the rows where RER < 1\n    filtered_df <- avg_stage_data %>%\n      filter(RER <= 1)\n    \n    # Fit third-degree polynomial models with intercept set to zero\n    fit_speed <- lm(FAT_gmin ~ 0 + poly(Speed_kph, 3, raw = TRUE), data = filtered_df)\n    fit_hr <- lm(FAT_gmin ~ 0 + poly(Perc_HR_peak, 3, raw = TRUE), data = filtered_df)\n    fit_vo2 <- lm(FAT_gmin ~ 0 + poly(Perc_VO2_peak, 3, raw = TRUE), data = filtered_df)\n    \n    # Create sequences for prediction\n    speed_seq <- seq(min(filtered_df$Speed_kph), max(filtered_df$Speed_kph), length.out = 1000)\n    hr_seq <- seq(min(filtered_df$Perc_HR_peak), max(filtered_df$Perc_HR_peak), length.out = 1000)\n    vo2_seq <- seq(min(filtered_df$Perc_VO2_peak), max(filtered_df$Perc_VO2_peak), length.out = 1000)\n    \n    # Predict FAT_gmin values using the polynomial models\n    pred_speed <- predict(fit_speed, newdata = data.frame(Speed_kph = speed_seq))\n    pred_hr <- predict(fit_hr, newdata = data.frame(Perc_HR_peak = hr_seq))\n    pred_vo2 <- predict(fit_vo2, newdata = data.frame(Perc_VO2_peak = vo2_seq))\n    \n    # Find the values that give the maximum FAT_gmin\n    max_index_speed <- which.max(pred_speed)\n    max_index_hr <- which.max(pred_hr)\n    max_index_vo2 <- which.max(pred_vo2)\n    \n    fatmax_speed <- speed_seq[max_index_speed]\n    fatmax_hr <- hr_seq[max_index_hr]\n    fatmax_vo2 <- vo2_seq[max_index_vo2]\n    \n    max_fat_oxidation_speed <- pred_speed[max_index_speed]\n    max_fat_oxidation_hr <- pred_hr[max_index_hr]\n    max_fat_oxidation_vo2 <- pred_vo2[max_index_vo2]\n    \n    # Update test_summary with new values\n    test_summary <- test_summary %>%\n      mutate(\n        Fatmax_kph = fatmax_speed,\n        Fatmax_HR = fatmax_hr,\n        Fatmax_VO2 = fatmax_vo2,\n        MFO_gmin = max_fat_oxidation_speed)\n    \n    return(test_summary)\n  }\n\n\n## Miscellaneous functions ===================================\n\n# Convert time in m:ss to seconds\nconvert_to_s <-\n  function(\n    time_str\n  ) {\n    \n    Time = lubridate::period_to_seconds(lubridate::ms(time_str, roll = TRUE))\n    return(Time)\n  }\n\n# Add % HRpeak and VO2peak columns to avg_stage_data\nadd_peak_percentages <-\n  function(\n    avg_stage_data,\n    test_summary\n  ) {\n    \n    HR_peak <- pull(test_summary, HR_peak)\n    VO2_peak <- pull(test_summary, VO2_peak)\n    \n    avg_stage_data <- avg_stage_data %>%\n      mutate(Perc_HR_peak = HR/HR_peak * 100,\n             Perc_VO2_peak = VO2/VO2_peak * 100)\n    \n    return(avg_stage_data)\n  }\n\n# Delete the rounded 'Time' column and mutate a minute decimal time column in the df\nfix_time <-\n  function(\n    data\n  ) {\n    \n    data <- data %>%\n      select(-Time) %>%\n      mutate(Time_m = Time_s / 60) %>%\n      relocate(Time_m, .after = Time_mss)\n    \n    return(data)\n  }\n\n# adjust parvo_eg_data based on exercise modality\nadjust_to_modality_parvo_eg_data <-\n  function(\n    parvo_eg_data,\n    test_summary,\n    exercise_mode,\n    power_unit\n  ) {\n    \n    if (exercise_mode %in% c(\"Cycle Ergometer\", \"Rowing Ergometer\")) {\n      parvo_eg_data <- parvo_eg_data %>%\n        select(-Speed_minkm,\n               -Speed_minkm_dec) %>%\n        rename(Power_W = Speed_kph)\n      \n      if (power_unit) {\n        parvo_eg_data <- parvo_eg_data %>%\n          mutate(Power_W_temp = Power_W * test_summary$Weight) %>%\n          relocate(Power_W_temp, .before = Power_W) %>%\n          rename(Power_Wkg = Power_W, Power_W = Power_W_temp)\n      } else {\n        parvo_eg_data <- parvo_eg_data %>%\n          mutate(Power_Wkg = Power_W / test_summary$Weight) %>%\n          relocate(Power_Wkg, .after = Power_W)\n      }\n    }\n    \n    return(parvo_eg_data)\n  }\n\n# adjust avg_stage_data based on exercise modality\nadjust_to_modality_avg_stage_data <-\n  function(\n    avg_stage_data,\n    test_summary,\n    exercise_mode,\n    power_unit\n  ) {\n    \n    add_avg_cycling_metrics <- function(avg_stage_data, test_summary, power_unit) {\n      \n      if (power_unit) {\n        avg_stage_data <- avg_stage_data %>%\n          mutate(\n            CE_LminW = VO2 / (Power_W * test_summary$Weight),\n            # Used by Lucia, 2002; Millet, 2003; Coyle, 1991 - did they have the units wrong?? Look at Table 4 of Coyle 1991\n            CE_WLmin = (Power_W * test_summary$Weight) / VO2,\n            # Used by Moseley & Jeukendrup, 2000\n            CE_kJL = (Power_W * test_summary$Weight) / VO2 * 60 / 1000,\n            # Calculated as ratio of work rate (W) to energy expended (J/s); Moseley & Jeukendrup, 2000\n            GE_Js = (Power_W * test_summary$Weight) / P_Js * 100,\n            # Calculated as ratio of work rate (kcal/min) to energy expended (kcal/min); Coyle, 1991\n            # Is 60/4184 correct conversion? Based on 4.184 J = 1 cal?\n            GE_kcalmin = ((Power_W * test_summary$Weight) * 60 / 4184) / EE_kcalmin * 100) %>%\n          relocate(CE_LminW, CE_WLmin, CE_kJL, GE_Js, GE_kcalmin, .before = Power_W)\n      } else {\n        avg_stage_data <- avg_stage_data %>%\n          mutate(\n            CE_LminW = VO2 / Power_W,\n            CE_WLmin = Power_W / VO2,\n            CE_kJL = Power_W / VO2 * 60 / 1000,\n            GE_Js = Power_W / P_Js * 100,\n            GE_kcalmin = (Power_W * 60 / 4184) / EE_kcalmin * 100) %>%\n          relocate(CE_LminW, CE_WLmin, CE_kJL, GE_Js, GE_kcalmin, .before = Power_W)\n      }\n      \n      return(avg_stage_data)\n    }\n    \n    if (exercise_mode %in% c(\"Cycle Ergometer\", \"Rowing Ergometer\")) {\n      avg_stage_data <- avg_stage_data %>%\n        select(-Speed_minkm,\n               -Speed_minkm_dec,\n               -RE_mlkgkm,\n               -RE_kcalkm,\n               -RE_kcalkgkm) %>%\n        rename(Power_W = Speed_kph)\n      \n      avg_stage_data <- add_avg_cycling_metrics(avg_stage_data, test_summary, power_unit)\n      \n      if (power_unit) {\n        avg_stage_data <- avg_stage_data %>%\n          mutate(Power_W_temp = Power_W * test_summary$Weight) %>%\n          relocate(Power_W_temp, .before = Power_W) %>%\n          rename(Power_Wkg = Power_W, Power_W = Power_W_temp)\n      } else {\n        avg_stage_data <- avg_stage_data %>%\n          mutate(Power_Wkg = Power_W / test_summary$Weight) %>%\n          relocate(Power_Wkg, .after = Power_W)\n      }\n    }\n    \n    return(avg_stage_data)\n    \n  }\n\n# adjust test_summary based on exercise modality\nadjust_to_modality_test_summary <-\n  function(\n    test_summary,\n    exercise_mode,\n    power_unit\n  ) {\n    \n    if (exercise_mode %in% c(\"Cycle Ergometer\", \"Rowing Ergometer\")) {\n      test_summary <- test_summary %>%\n        rename(pVO2max = vVO2max,\n               W_peak = V_peak,\n               Fatmax_W = Fatmax_kph)# %>%\n      # add delta efficiency code here\n      \n      if (power_unit) {\n        test_summary <- test_summary %>%\n          mutate(pVO2max_W_temp = pVO2max * Weight,\n                 W_peak_temp = W_peak * Weight,\n                 Fatmax_W_temp = Fatmax_W * Weight) %>%\n          relocate(pVO2max_W_temp, .before = pVO2max) %>%\n          relocate(W_peak_temp, .before = W_peak) %>%\n          relocate(Fatmax_W_temp, .before = Fatmax_W) %>%\n          rename(pVO2max_Wkg = pVO2max, pVO2max_W = pVO2max_W_temp,\n                 Wkg_peak = W_peak, W_peak = W_peak_temp,\n                 Fatmax_Wkg = Fatmax_W, Fatmax_W = Fatmax_W_temp)\n      } else {\n        test_summary <- test_summary %>%\n          mutate(pVO2max_Wkg = pVO2max / Weight,\n                 Wkg_peak = W_peak / Weight,\n                 Fatmax_Wkg = Fatmax_W / Weight) %>%\n          relocate(pVO2max_Wkg, .after = pVO2max) %>%\n          rename(pVO2max_W = pVO2max) %>%\n          relocate(Wkg_peak, .after = W_peak) %>%\n          relocate(Fatmax_Wkg, .after = Fatmax_W)\n      }\n    }\n    \n    return(test_summary)\n    \n  }\n\n# Add thresholds and zone info to test_summary\nadd_threshold_zone <-\n  function(\n    threshold_zone_info,\n    test_summary\n  ) {\n    \n    threshold_zone <- threshold_zone_info()\n    \n    for (col in names(threshold_zone)) {\n      if (!all(is.na(threshold_zone[[col]]))) {\n        test_summary[[col]] <- threshold_zone[[col]]\n      }\n    }\n    \n    return(test_summary)\n    \n  }\n\n# # Add marathon race prediction times to test_summary\n# add_race_prediction <-\n#   function(\n    #     exercise_mode,\n#     test_summary\n#   ) {\n#     \n#     if (exercise_mode == \"Treadmill\") {\n#       test_summary$\n#     }\n#     \n#     return(test_summary)\n#     \n#   }\n\n# Remove empty columns\nremove_empty_columns <- function(df){\n  \n  # Remove columns where all values are NA or empty\n  df_cleaned <- df[, colSums(!is.na(df) & df != \"\") > 0]\n  \n  return(df_cleaned)\n}\n\n### CREATE SHINY APP USER INTERFACE ==========================\n## Creating sidebar UI =======================================\n\nsidebar <- dashboardSidebar(\n  sidebarMenu(\n    menuItem(\"About the app\", tabName = \"about\", icon = icon(\"circle-question\"),\n             menuSubItem(\"General Outline\", tabName = \"app_outline\"),\n             menuSubItem(\"Usage Guide\", tabName = \"instructions\"),\n             menuSubItem(\"Glossary\", tabName = \"glossary\"),\n             startExpanded = TRUE),\n    menuItem(\"Step Test\", tabName = \"step_test_processor\", icon = icon(\"stairs\"),\n             menuSubItem(\"Options\", tabName = \"step_test_options\"),\n             menuSubItem(\"Test Summary\", tabName = \"step_test_summary\"),\n             menuSubItem(\"Average Stage Data\", tabName = \"step_avg_stage_data\"),\n             menuSubItem(\"Parvo EG Data\", tabName = \"step_parvo_eg_data\"),\n             menuSubItem(\"Graphs\", tabName = \"graphs\")),\n    # menuItem(\"Ramp Test\", tabName = \"ramp_test_processor\", icon = icon(\"chart-line\"),\n    #          menuSubItem(\"Options\", tabName = \"ramp_test_options\"),\n    #          menuSubItem(\"Test Summary\", tabName = \"ramp_test_summary\"),\n    #          menuSubItem(\"Average Stage Data\", tabName = \"ramp_avg_stage_data\"),\n    #          menuSubItem(\"Parvo EG Data\", tabName = \"ramp_parvo_eg_data\")),\n    menuItem(\"ExPhysLab Tools\", tabName = \"ExPhysLab Tools\", lib = \"font-awesome\", icon = icon(\"screwdriver-wrench\"),\n             menuSubItem(\"Lactate Thresholds App\", tabName = \"lactate_thresholds\"),\n             menuSubItem(\"Exercise Thresholds App\", tabName = \"exercise_thresholds\"))\n  )\n)\n\n## Creating body UI ==========================================\n\n# Sets the theme of dashboard\nmy_theme = create_theme(\n  adminlte_color(\n    light_blue = \"#111\"\n  )\n)\n\n# Codes the dashboardBody\nbody <- dashboardBody(\n  use_theme(my_theme),\n  tabItems(\n    tabItem(tabName = \"app_outline\",\n            includeMarkdown(\"App Outline.md\")\n    ),\n    tabItem(tabName = \"instructions\",\n            includeMarkdown(\"Instructions.md\")\n            \n    ),\n    tabItem(tabName = \"glossary\",\n            includeMarkdown(\"Glossary.md\")\n    ),\n    tabItem(tabName = \"step_test_options\",\n            fluidPage(\n              fluidRow(\n                box(\n                  title = \"Exercise Modality\",\n                  width = 6,\n                  status = \"success\", solidHeader = TRUE,\n                  radioGroupButtons(\"modality\", \"Select the Exercise Modality\", choices = c(\"Treadmill\", \"Cycle Ergometer\", \"Rowing Ergometer\"), status = \"primary\")\n                ),\n                box(\n                  title = \"Process the Data\",\n                  width = 6,\n                  status = \"success\", solidHeader = TRUE,\n                  actionButton(\"process\", \"Process Data\")\n                )),\n              fluidRow(\n                box(\n                  title = \"Upload File\",\n                  width = 4,\n                  \"Upload the raw file exported directly from the Parvo Medics' TrueOne\",\n                  status = \"primary\", solidHeader = TRUE,\n                  fileInput(\"file\", \"Upload Parvo File\", accept = c(\".xls\", \".xlsx\"))\n                ),\n                box(\n                  title = \"Written Info\",\n                  width = 4,\n                  \"Fill in the table with the information manually recorded during the test\",\n                  status = \"primary\", solidHeader = TRUE,\n                  h1(\"Number of Stages\"), \n                  fluidRow(\n                    column(2, actionButton(\"remove_stage\", label = NULL, icon = icon(\"minus\"), class = \"btn btn-danger\")),\n                    column(7, numericInput(\"stage_counter\", label = NULL, value = 5, min = 1, width = \"100%\")),\n                    column(2, actionButton(\"add_stage\", label = NULL, icon = icon(\"plus\"), class = \"btn btn-success\"))),\n                  rHandsontableOutput(\"stage_table\")\n                ),\n                box(\n                  title = \"Protocol Options\",\n                  width = 4,\n                  \"Select the protocol design of the GXT\",\n                  status = \"primary\", solidHeader = TRUE,\n                  uiOutput(\"protocol_1_start_input_ui\"),\n                  uiOutput(\"protocol_1_increase_input_ui\"),\n                  uiOutput(\"power_unit_switch_ui\"),\n                  textInput(\"protocol_1_length_input\", \"Length of Stage (m:ss)\", \"3:00\"),\n                  textInput(\"end_time_input\", \"End Time (m:ss)\")\n                )),\n              fluidRow(\n                box(\n                  title = \"Baseline Options\",\n                  width = 4,\n                  \"If a baseline stage was completed, select the options\",\n                  status = \"warning\", solidHeader = TRUE,\n                  switchInput(\"has_baseline\", \"Has Baseline Stage\", TRUE),\n                  textInput(\"baseline_time\", \"Duration of Baseline Stage (m:ss)\", \"1:00\"),\n                  uiOutput(\"baseline_intensity_input_ui\"),\n                ),\n                box(\n                  title = \"Break Options\",\n                  width = 4,\n                  \"If a break was used between submaximal stages, select the options\",\n                  status = \"warning\", solidHeader = TRUE,\n                  switchInput(\"has_break\", \"Has Break\", TRUE),\n                  textInput(\"break_length_input\", \"Length of Breaks (m:ss)\", \"0:30\"),\n                  uiOutput(\"break_speed_input_ui\"),\n                ),\n                box(\n                  title = \"Second Protocol Options\",\n                  width = 4,\n                  \"If there was a change in protocol in the middle of the test, select the options\",\n                  status = \"warning\", solidHeader = TRUE,\n                  switchInput(\"has_protocol_2\", \"Has Second Protocol (i.e., new step parameters)\", TRUE),\n                  textInput(\"when_protocol_2\", \"When Second Protocol Begins (m:ss)\"),\n                  uiOutput(\"protocol_2_start_input_ui\"),\n                  uiOutput(\"protocol_2_increase_input_ui\"),\n                  textInput(\"protocol_2_length_input\", \"Length of Stage of Second Protocol (m:ss)\", \"1:00\")\n                )),\n              fluidRow(\n                box(\n                  title = \"Advanced Options\",\n                  width = 4,\n                  status = \"danger\", solidHeader = TRUE,\n                  #collapsible = TRUE, collapsed = TRUE,\n                  numericInput(\"avg_interval\", \"Calculation Intervals for Averages during Processing (seconds)\", 30),\n                  switchInput(\"include_last_row_input\", \"Include Last Row of Each Stage in Averaging\", FALSE),\n                  pickerInput(\"vars_of_interest\", \"Variables of Interest\", \n                              choices = c(\"Lactate\", \"RPE\", \"HR\", \"VO2\", \"VO2kg\", \"VCO2\", \"RER\", \"RR\", \"VT\", \"VE\"), \n                              selected = c(\"Lactate\", \"RPE\", \"HR\", \"VO2\", \"VO2kg\"), multiple = TRUE)\n                ),\n                box(\n                  title = \"Exercise Thresholds and Zones\",\n                  width = 8,\n                  status = \"danger\", solidHeader = TRUE,\n                  rHandsontableOutput(\"threshold_table\"),\n                  rHandsontableOutput(\"zone_table\")\n                )\n              )\n            )\n    ),\n    tabItem(tabName = \"step_test_summary\",\n            downloadButton(\"download_step_test_summary_data_excel\", \"Excel\"),\n            downloadButton(\"download_step_test_summary_data_csv\", \"CSV\"),\n            fluidRow(\n              box(\n                title = \"Test Summary\",\n                uiOutput(\"message_before_processing_tst\"),\n                rHandsontableOutput(\"test_summary_table\"),\n                width = 12,\n                style = \"height: 85vh; overflow-y: scroll; overflow-x: scroll;\"\n              )\n            )\n    ),\n    tabItem(tabName = \"step_avg_stage_data\",\n            downloadButton(\"download_step_avg_stage_data_excel\", \"Excel\"),\n            downloadButton(\"download_step_avg_stage_data_csv\", \"CSV\"),\n            fluidRow(\n              box(\n                title = \"Average Stage Data\",\n                uiOutput(\"message_before_processing_asdt\"),\n                rHandsontableOutput(\"avg_stage_data_table\"),\n                width = 12,\n                style = \"height: 85vh; overflow-y: scroll; overflow-x: scroll;\"\n              )\n            )\n    ),\n    tabItem(tabName = \"step_parvo_eg_data\",\n            downloadButton(\"download_step_parvo_eg_data_excel\", \"Excel\"),\n            downloadButton(\"download_step_parvo_eg_data_csv\", \"CSV\"),\n            fluidRow(\n              box(\n                title = \"Parvo EG Data\",\n                uiOutput(\"message_before_processing_pedt\"),\n                rHandsontableOutput(\"parvo_eg_data_table\"),\n                width = 12\n                #, style = \"height: 85vh; overflow-y: scroll; overflow-x: scroll;\"\n              )\n            )\n    ),\n    tabItem(tabName = \"graphs\",\n            sidebarLayout(\n              sidebarPanel(\n                # Controls for Parvo EG Data\n                fluidRow(\n                  box(\n                    title = \"Parvo EG Graph Controls\",\n                    status = \"primary\",\n                    solidHeader = TRUE,\n                    width = 12,\n                    uiOutput(\"parvo_data_y_var_ui\"),\n                    uiOutput(\"parvo_data_x_var_ui\")\n                  )\n                ),\n                # Controls for Average Stage Data\n                fluidRow(\n                  box(\n                    title = \"Average Stage Graph Controls\",\n                    status = \"primary\",\n                    solidHeader = TRUE,\n                    width = 12,\n                    uiOutput(\"avg_stage_y_var_ui\"),\n                    uiOutput(\"avg_stage_x_var_ui\")\n                  )\n                )\n              ),\n              mainPanel(\n                box(\n                  title = \"Parvo Data Plot\",\n                  status = \"primary\",\n                  solidHeader = TRUE,\n                  width = NULL,\n                  plotlyOutput(\"parvo_eg_plot\")\n                ),\n                box(\n                  title = \"Average Stage Data Plot\",\n                  status = \"primary\",\n                  solidHeader = TRUE,\n                  width = NULL,\n                  plotlyOutput(\"avg_stage_plot\")\n                )\n              )\n            )\n    ),\n    # tabItem(tabName = \"ramp_test_options\",\n    #         mainPanel(\"Coming soon\")\n    # ),\n    # tabItem(tabName = \"ramp_test_summary\",\n    #         mainPanel(\"Coming soon\")\n    # ),\n    # tabItem(tabName = \"ramp_avg_stage_data\",\n    #         mainPanel(\"Coming soon\")\n    # ),\n    # tabItem(tabName = \"ramp_parvo_eg_data\",\n    #         mainPanel(\"Coming soon\")\n    # ),\n    tabItem(tabName = \"lactate_thresholds\",\n            tags$iframe(src = \"https://www.exphyslab.com/lactate\",\n                        width = \"100%\",\n                        style = \"height: 85vh;\")\n    ),\n    tabItem(tabName = \"exercise_thresholds\",\n            tags$iframe(src = \"https://www.exercisethresholds.com/analyze\",\n                        width = \"100%\",\n                        style = \"height: 85vh;\")\n    )\n  )\n)\n\n# Code to define UI\nui <- dashboardPage(\n  dashboardHeader(title = \"Expired Gas Data Processing\"),\n  sidebar,\n  body\n)\n\n### DEFINE THE SERVER LOGIC ==================================\n\nserver <- function(input, output, session) {\n  \n  ## Server code related to stage_info table ========================\n  \n  # Reactive expression to create default stage_info df\n  initial_stage_info_data <- reactive({\n    if (input$modality == \"Cycle Ergometer\") {\n      data.frame(\n        Stage = paste0(\"Stage_\", 1:5),\n        Cadence = 90,\n        Lactate = as.numeric(NA),\n        RPE = as.numeric(NA)\n      )\n    } else if (input$modality == \"Rowing Ergometer\") {\n      data.frame(\n        Stage = paste0(\"Stage_\", 1:5),\n        Stroke_Rate = 30,\n        Lactate = as.numeric(NA),\n        RPE = as.numeric(NA)\n      )\n    } else {\n      data.frame(\n        Stage = paste0(\"Stage_\", 1:5),\n        Grade = 1,\n        Lactate = as.numeric(NA),\n        RPE = as.numeric(NA)\n      )\n    }\n  })\n  \n  # Reactive values to hold the table data\n  written_info <- reactiveVal()\n  observe({\n    written_info(initial_stage_info_data())\n  })\n  \n  # Observe changes in stage_counter and modality to update the table\n  observe({\n    current_rows <- nrow(written_info())\n    if (input$stage_counter > current_rows) {\n      additional_rows <-\n        if (input$modality == \"Cycle Ergometer\") {\n          data.frame(\n            Stage = paste0(\"Stage_\", (current_rows + 1):input$stage_counter),\n            Cadence = 90,\n            Lactate = as.numeric(NA),\n            RPE = as.numeric(NA)\n          )\n        } else if (input$modality == \"Rowing Ergometer\") {\n          data.frame(\n            Stage = paste0(\"Stage_\", (current_rows + 1):input$stage_counter),\n            Stroke_Rate = 30,\n            Lactate = as.numeric(NA),\n            RPE = as.numeric(NA)\n          )\n        } else {\n          data.frame(\n            Stage = paste0(\"Stage_\", (current_rows + 1):input$stage_counter),\n            Grade = 1,\n            Lactate = as.numeric(NA),\n            RPE = as.numeric(NA)\n          )\n        }\n      written_info(rbind(written_info(), additional_rows))\n    } else if (input$stage_counter < current_rows) {\n      written_info(written_info()[1:input$stage_counter, ])\n    }\n  })\n  \n  observeEvent(input$add_stage, {\n    updateNumericInput(session, \"stage_counter\", value = input$stage_counter + 1)\n  })\n  \n  observeEvent(input$remove_stage, {\n    if (input$stage_counter > 1) {\n      updateNumericInput(session, \"stage_counter\", value = input$stage_counter - 1)\n    }\n  })\n  \n  # Observe changes in modality to reset the table with correct column names\n  observeEvent(input$modality, {\n    written_info(initial_stage_info_data())\n  })\n  \n  # Renders the stage_info table\n  output$stage_table <- renderRHandsontable({\n    if (input$modality == \"Cycle Ergometer\") {\n      rhandsontable(written_info(), rowHeaders = NULL) %>%\n        hot_col(\"Cadence\", type = \"numeric\") %>%\n        hot_col(\"Lactate\", type = \"numeric\") %>%\n        hot_col(\"RPE\", type = \"numeric\")\n    } else if (input$modality == \"Rowing Ergometer\") {\n      rhandsontable(written_info(), rowHeaders = NULL) %>%\n        hot_col(\"Stroke_Rate\", type = \"numeric\") %>%\n        hot_col(\"Lactate\", type = \"numeric\") %>%\n        hot_col(\"RPE\", type = \"numeric\")\n    } else {\n      rhandsontable(written_info(), rowHeaders = NULL) %>%\n        hot_col(\"Grade\", type = \"numeric\") %>%\n        hot_col(\"Lactate\", type = \"numeric\") %>%\n        hot_col(\"RPE\", type = \"numeric\")\n    }\n  })\n  \n  # Update the written_info variable with the contents of the table whenever it's edited\n  observe({\n    if (!is.null(input$stage_table)) {\n      written_info(hot_to_r(input$stage_table))\n    }\n  })\n  \n  ## Server code related to exercise thresholds and zones ===========\n  \n  # Reactive expression to create default info for exercise thresholds\n  initial_threshold_data <- reactive({\n    if (input$modality == \"Treadmill\") {\n      data.frame(\n        Speed_LT1 = as.numeric(NA),\n        VO2_LT1 = as.numeric(NA),\n        BLa_LT1 = as.numeric(NA),\n        Speed_LT2 = as.numeric(NA),\n        VO2_LT2 = as.numeric(NA),\n        BLa_LT2 = as.numeric(NA)\n      )\n    } else {\n      data.frame(\n        Power_LT1 = as.numeric(NA),\n        VO2_LT1 = as.numeric(NA),\n        BLa_LT1 = as.numeric(NA),\n        Power_LT2 = as.numeric(NA),\n        VO2_LT2 = as.numeric(NA),\n        BLa_LT2 = as.numeric(NA)\n      )\n    }\n  })\n  \n  # Reactive expression to create default info for exercise zones\n  initial_zone_data <- reactive({\n    if (input$modality == \"Treadmill\") {\n      data.frame(\n        Speed_Z1 = as.character(NA),\n        HR_Z1 = as.character(NA),\n        RPE_Z1 = as.character(NA),\n        Speed_Z2 = as.character(NA),\n        HR_Z2 = as.character(NA),\n        RPE_Z2 = as.character(NA),\n        Speed_Z3 = as.character(NA),\n        HR_Z3 = as.character(NA),\n        RPE_Z3 = as.character(NA)\n      )\n    } else {\n      data.frame(\n        Power_Z1 = as.character(NA),\n        HR_Z1 = as.character(NA),\n        RPE_Z1 = as.character(NA),\n        Power_Z2 = as.character(NA),\n        HR_Z2 = as.character(NA),\n        RPE_Z2 = as.character(NA),\n        Power_Z3 = as.character(NA),\n        HR_Z3 = as.character(NA),\n        RPE_Z3 = as.character(NA)\n      )\n    }\n  })\n  \n  # Reactive values to hold the exercise thresholds table data\n  threshold_info <- reactiveVal()\n  observe({\n    threshold_info(initial_threshold_data())\n  })\n  \n  # Reactive values to hold the exercise zones table data\n  zone_info <- reactiveVal()\n  observe({\n    zone_info(initial_zone_data())\n  })\n  \n  # Observe changes in modality to reset the exercise thresholds table with correct column names\n  observeEvent(input$modality, {\n    threshold_info(initial_threshold_data())\n  })\n  \n  # Observe changes in modality to reset the zones table with correct column names\n  observeEvent(input$modality, {\n    zone_info(initial_zone_data())\n  })\n  \n  # Renders the exercise thresholds table\n  output$threshold_table <- renderRHandsontable({\n    if (input$modality == \"Treadmill\") {\n      rhandsontable(threshold_info(), rowHeaders = NULL) %>%\n        hot_col(\"Speed_LT1\", type = \"numeric\") %>%\n        hot_col(\"VO2_LT1\", type = \"numeric\") %>%\n        hot_col(\"BLa_LT1\", type = \"numeric\") %>%\n        hot_col(\"Speed_LT2\", type = \"numeric\") %>%\n        hot_col(\"VO2_LT2\", type = \"numeric\") %>%\n        hot_col(\"BLa_LT2\", type = \"numeric\")\n    } else {\n      rhandsontable(threshold_info(), rowHeaders = NULL) %>%\n        hot_col(\"Power_LT1\", type = \"numeric\") %>%\n        hot_col(\"VO2_LT1\", type = \"numeric\") %>%\n        hot_col(\"BLa_LT1\", type = \"numeric\") %>%\n        hot_col(\"Power_LT2\", type = \"numeric\") %>%\n        hot_col(\"VO2_LT2\", type = \"numeric\") %>%\n        hot_col(\"BLa_LT2\", type = \"numeric\")\n    }\n  })\n  \n  # Renders the exercise zones table\n  output$zone_table <- renderRHandsontable({\n    if (input$modality == \"Treadmill\") {\n      rhandsontable(zone_info(), rowHeaders = NULL) %>%\n        hot_col(\"Speed_Z1\") %>%\n        hot_col(\"HR_Z1\") %>%\n        hot_col(\"RPE_Z1\") %>%\n        hot_col(\"Speed_Z2\") %>%\n        hot_col(\"HR_Z2\") %>%\n        hot_col(\"RPE_Z2\") %>%\n        hot_col(\"Speed_Z3\") %>%\n        hot_col(\"HR_Z3\") %>%\n        hot_col(\"RPE_Z3\")\n    } else {\n      rhandsontable(zone_info(), rowHeaders = NULL) %>%\n        hot_col(\"Power_Z1\") %>%\n        hot_col(\"HR_Z1\") %>%\n        hot_col(\"RPE_Z1\") %>%\n        hot_col(\"Power_Z2\") %>%\n        hot_col(\"HR_Z2\") %>%\n        hot_col(\"RPE_Z2\") %>%\n        hot_col(\"Power_Z3\") %>%\n        hot_col(\"HR_Z3\") %>%\n        hot_col(\"RPE_Z3\")\n    }\n  })\n  \n  # Update the written_info variable with the contents of the exercise thresholds table whenever it's edited\n  observe({\n    if (!is.null(input$threshold_table)) {\n      threshold_info(hot_to_r(input$threshold_table))\n    }\n  })\n  \n  # Update the written_info variable with the contents of the exercise zones table whenever it's edited\n  observe({\n    if (!is.null(input$zone_table)) {\n      zone_info(hot_to_r(input$zone_table))\n    }\n  })\n  \n  ## Server code related to exercise modality =======================\n  \n  # Modify UI based on modality chosen\n  renderNumericInput <- function(inputId, labelBase, defaultValues) {\n    renderUI({\n      if (input$modality == \"Cycle Ergometer\") {\n        unit <- ifelse(input$power_unit_switch, \"W/kg\", \"W\")\n        defaultValue <- defaultValues[[paste(\"Cycle Ergometer\", unit)]]\n        label <- paste(labelBase, \" (\", unit, \")\", sep = \"\")\n      } else if (input$modality == \"Rowing Ergometer\") {\n        unit <- ifelse(input$power_unit_switch, \"W/kg\", \"W\")\n        defaultValue <- defaultValues[[paste(\"Rowing Ergometer\", unit)]]\n        label <- paste(labelBase, \" (\", unit, \")\", sep = \"\")\n      } else {\n        unit <- \"kph\"\n        defaultValue <- defaultValues[[\"Treadmill kph\"]]\n        label <- paste(labelBase, \" (\", unit, \")\", sep = \"\")\n      }\n      numericInput(inputId, label, defaultValue)\n    })\n  }\n  \n  observeEvent(input$modality, {\n    if (input$modality %in% c(\"Cycle Ergometer\", \"Rowing Ergometer\")) {\n      output$power_unit_switch_ui <- renderUI({\n        materialSwitch(\"power_unit_switch\", label = \"Input in W/kg\", status = \"primary\", value = FALSE)\n      })\n    } else {\n      output$power_unit_switch_ui <- renderUI({\n        NULL\n      })\n    }\n  })\n  \n  observe({\n    modality <- input$modality\n    \n    # Define labels based on modality\n    labels <- list(\n      protocol_1_start = if (modality == \"Treadmill\") \"Starting Speed\" else \"Starting Power\",\n      protocol_1_increase = if (modality == \"Treadmill\") \"Speed Increments\" else \"Power Increments\",\n      baseline_intensity = if (modality == \"Treadmill\") \"Speed during Baseline Stage\" else \"Power during Baseline Stage\",\n      break_speed = if (modality == \"Treadmill\") \"Speed during Breaks\" else \"Power during Breaks\",\n      protocol_2_start = if (modality == \"Treadmill\") \"Starting Speed of Second Protocol\" else \"Starting Power of Second Protocol\",\n      protocol_2_increase = if (modality == \"Treadmill\") \"Speed Increments of Second Protocol\" else \"Power Increments of Second Protocol\"\n    )\n    \n    output$protocol_1_start_input_ui <- renderNumericInput(\n      \"protocol_1_start_input\", labels$protocol_1_start,\n      list(\"Cycle Ergometer W\" = NA, \"Cycle Ergometer W/kg\" = NA, \"Rowing Ergometer W\" = NA, \"Rowing Ergometer W/kg\" = NA, \"Treadmill kph\" = NA)\n    )\n    output$protocol_1_increase_input_ui <- renderNumericInput(\n      \"protocol_1_increase_input\", labels$protocol_1_increase,\n      list(\"Cycle Ergometer W\" = 25, \"Cycle Ergometer W/kg\" = 0.3, \"Rowing Ergometer W\" = 25, \"Rowing Ergometer W/kg\" = 0.3, \"Treadmill kph\" = 1)\n    )\n    output$baseline_intensity_input_ui <- renderNumericInput(\n      \"baseline_intensity_input\", labels$baseline_intensity,\n      list(\"Cycle Ergometer W\" = 0, \"Cycle Ergometer W/kg\" = 0, \"Rowing Ergometer W\" = 0, \"Rowing Ergometer W/kg\" = 0, \"Treadmill kph\" = 0)\n    )\n    output$break_speed_input_ui <- renderNumericInput(\n      \"break_speed_input\", labels$break_speed,\n      list(\"Cycle Ergometer W\" = 0, \"Cycle Ergometer W/kg\" = 0, \"Rowing Ergometer W\" = 0, \"Rowing Ergometer W/kg\" = 0, \"Treadmill kph\" = 0)\n    )\n    output$protocol_2_start_input_ui <- renderNumericInput(\n      \"protocol_2_start_input\", labels$protocol_2_start,\n      list(\"Cycle Ergometer W\" = NA, \"Cycle Ergometer W/kg\" = NA, \"Rowing Ergometer W\" = NA, \"Rowing Ergometer W/kg\" = NA, \"Treadmill kph\" = NA)\n    )\n    output$protocol_2_increase_input_ui <- renderNumericInput(\n      \"protocol_2_increase_input\", labels$protocol_2_increase,\n      list(\"Cycle Ergometer W\" = 25, \"Cycle Ergometer W/kg\" = 0.35, \"Rowing Ergometer W\" = 25, \"Rowing Ergometer W/kg\" = 0.3, \"Treadmill kph\" = 1)\n    )\n  })\n  \n  \n  # Code to create reactive values for graphing\n  reactive_avg_stage_data_graphing <- reactiveVal(NULL)\n  reactive_parvo_data_graphing <- reactiveVal(NULL)\n  \n  ## Server code related to 'saving' any edits made to the tables ====\n  \n  # Code to create reactive values for the table outputs\n  reactive_test_summary <- reactiveVal(NULL)\n  reactive_avg_stage_data <- reactiveVal(NULL)\n  reactive_parvo_eg_data <- reactiveVal(NULL)\n  \n  # Code that updates each of the table whenever edits are made\n  observe({\n    if (!is.null(input$test_summary_table)) {\n      reactive_test_summary(hot_to_r(input$test_summary_table))\n    }\n  })\n  \n  observe({\n    if (!is.null(input$avg_stage_data_table)) {\n      updated_avg_stage_data <- hot_to_r(input$avg_stage_data_table)\n      reactive_avg_stage_data(updated_avg_stage_data)\n      \n      # Update the graphs to reflect any edits made to the avg_stage_data_table\n      current_avg_stage_data <- reactive_avg_stage_data_graphing()\n      if (!is.null(current_avg_stage_data)) {\n        current_avg_stage_data <- updated_avg_stage_data\n        reactive_avg_stage_data_graphing(current_avg_stage_data)\n      }\n    }\n  })\n  \n  observe({\n    if (!is.null(input$parvo_eg_data_table)) {\n      updated_parvo_eg_data <- hot_to_r(input$parvo_eg_data_table)\n      reactive_parvo_eg_data(updated_parvo_eg_data)\n      \n      # Update the graphs to reflect any edits made to the parvo_eg_data_table\n      current_parvo_data <- reactive_parvo_data_graphing()\n      if (!is.null(current_parvo_data)) {\n        current_parvo_data$parvo_eg_data <- updated_parvo_eg_data\n        reactive_parvo_data_graphing(current_parvo_data)\n      }\n    }\n  })\n  \n  ## Server code related to message prior to processing data =========\n  \n  output$message_before_processing_tst <- renderUI({\n    if (input$process == 0) {\n      h3(\"To preview the Test Summary table, please go to 'Options' and process the data first.\")\n    }})\n  \n  output$message_before_processing_asdt <- renderUI({\n    if (input$process == 0) {\n      h3(\"To preview the Average Stage Data table, please go to 'Options' and process the data first.\")\n    }})\n  \n  output$message_before_processing_pedt <- renderUI({\n    if (input$process == 0) {\n      h3(\"To preview the highest fidelity data table, please go to 'Options' and process the data first.\")\n    }})\n  \n  ## Server code that runs after \"Process\" is initiated =============\n  \n  # Code that reads in the inputs from the Shiny interface and processes the data\n  observeEvent(input$process, {\n    \n    withProgress(message = \"Processing data...\", value = 0, {\n      incProgress(0.05, detail = \"Reading and preparing data...\")\n      \n      file_of_interest <- suppressMessages(read_excel(input$file$datapath))\n      modality <- input$modality\n      power_unit <- input$power_unit_switch\n      has_baseline <- input$has_baseline\n      baseline_time <- convert_to_s(input$baseline_time)\n      baseline_intensity_input <- input$baseline_intensity_input\n      protocol_1_start_input <- input$protocol_1_start_input\n      protocol_1_increase_input <- input$protocol_1_increase_input\n      protocol_1_length_input <- convert_to_s(input$protocol_1_length_input)\n      has_protocol_2 <- input$has_protocol_2\n      when_protocol_2 <- convert_to_s(input$when_protocol_2)\n      protocol_2_start_input <- input$protocol_2_start_input\n      protocol_2_increase_input <- input$protocol_2_increase_input\n      protocol_2_length_input <- convert_to_s(input$protocol_2_length_input)\n      has_break <- input$has_break\n      break_length_input <- convert_to_s(input$break_length_input)\n      break_speed_input <- input$break_speed_input\n      avg_interval <- input$avg_interval\n      include_last_row_input <- input$include_last_row_input\n      cols_of_interest <- input$vars_of_interest\n      end_time_input <- convert_to_s(input$end_time_input)\n      \n      incProgress(0.15, detail = \"Processing and analyzing data...\")\n      \n      # create parvo_data list with 2 tibbles (parvo_metadata and parvo_eg_data) and add some variables of interest\n      parvo_data <-\n        parvo_process(\n          parvo_data_raw = file_of_interest\n        ) %>%\n        print()\n      \n      # Remove all rows that exceed the end of the test\n      parvo_data$parvo_eg_data <-\n        remove_post_test_rows(\n          data = parvo_data$parvo_eg_data,\n          input_time = end_time_input,\n          use_baseline = has_baseline,\n          baseline_length = baseline_time\n        ) %>%\n        print()\n      \n      # make time easier to work with by creating new column rounding time to averaging intervals\n      parvo_data$parvo_eg_data <-\n        replace_with_closest_multiple(\n          data = parvo_data$parvo_eg_data\n        ) %>%\n        print()\n      \n      # add \"Speed\", \"Protocol\", \"Stage\" columns\n      parvo_data$parvo_eg_data <-\n        assign_intensity(\n          data = parvo_data$parvo_eg_data,\n          use_baseline = has_baseline,\n          baseline_length = baseline_time,\n          baseline_intensity = baseline_intensity_input,\n          protocol_1_start = protocol_1_start_input,\n          protocol_1_increase = protocol_1_increase_input,\n          protocol_1_length = protocol_1_length_input,\n          use_protocol_2 = has_protocol_2,\n          time_of_change = when_protocol_2,\n          protocol_2_start = protocol_2_start_input,\n          protocol_2_increase = protocol_2_increase_input,\n          protocol_2_length = protocol_2_length_input,\n          use_break = has_break,\n          break_length = break_length_input,\n          break_speed = break_speed_input\n        ) %>%\n        print()\n      \n      # assign \"Grade/Cadence\", \"Lactate\", and \"RPE\" data columns from Shiny manually inputted table\n      parvo_data$parvo_eg_data <-\n        assign_written_info(\n          data = parvo_data$parvo_eg_data,\n          stage_info = written_info,\n          exercise_mode = modality\n        ) %>%\n        print()\n      \n      incProgress(0.35, detail = \"Creating avg stage data df ...\")\n      \n      # create the average stage data file, while ignoring the columns listed\n      avg_stage_data <-\n        process_stage_avgs(\n          data = parvo_data$parvo_eg_data,\n          include_last_row = include_last_row_input,\n          averaging_interval = avg_interval\n        ) %>%\n        print()\n      \n      # add running economy and metabolic power variables of interest\n      avg_stage_data <-\n        add_re_mp(\n          data = avg_stage_data,\n          athlete_df = parvo_data$parvo_metadata\n        ) %>%\n        print()\n      \n      incProgress(0.5, detail = \"Creating test summary df ...\")\n      \n      # determine peak values for variables of interest and generate new test_summary df\n      test_summary <-\n        process_peak_data(\n          data = parvo_data$parvo_eg_data,\n          meta_data = parvo_data$parvo_metadata,\n          averaging_interval = avg_interval,\n          cols_interest = cols_of_interest,\n          end_time = end_time_input,\n          protocol_1_increase = protocol_1_increase_input,\n          protocol_1_length = protocol_1_length_input,\n          use_break = has_break,\n          break_length = break_length_input,\n          use_protocol_2 = has_protocol_2,\n          protocol_2_increase = protocol_2_increase_input,\n          protocol_2_length = protocol_2_length_input,\n          use_baseline = has_baseline,\n          baseline_length = baseline_time\n        ) %>%\n        print()\n      \n      # assign normative info related to VO2max\n      test_summary <-\n        assign_VO2max_norms(\n          athlete_characteristics_df = test_summary,\n          exercise_mode = modality\n        ) %>%\n        print()\n      \n      # add vVO2max to test_summary\n      test_summary <-\n        workload_at_vo2max(\n          avg_stage_data,\n          summary = test_summary\n        ) %>%\n        print()\n      \n      # add % HRpeak and VO2peak columns to avg_stage_data\n      avg_stage_data <-\n        add_peak_percentages(\n          avg_stage_data,\n          test_summary\n        ) %>%\n        print()\n      \n      # add FATmax and MFO \n      test_summary <-\n        calculate_fatmax(\n          avg_stage_data,\n          test_summary\n        ) %>%\n        print()\n      \n      incProgress(0.7, detail = \"Adjusting to the exercise modality ...\")\n      \n      # adjust parvo_eg_data based on exercise modality\n      parvo_data$parvo_eg_data <-\n        adjust_to_modality_parvo_eg_data(\n          parvo_eg_data = parvo_data$parvo_eg_data,\n          test_summary = test_summary,\n          exercise_mode = modality,\n          power_unit = power_unit\n        ) %>%\n        print()\n      \n      # adjust avg_stage_data based on exercise modality\n      avg_stage_data <-\n        adjust_to_modality_avg_stage_data(\n          avg_stage_data = avg_stage_data,\n          test_summary = test_summary,\n          exercise_mode = modality,\n          power_unit = power_unit\n        ) %>%\n        print()\n      \n      # adjust test_summary based on exercise modality\n      test_summary <-\n        adjust_to_modality_test_summary(\n          test_summary = test_summary,\n          exercise_mode = modality,\n          power_unit = power_unit\n        ) %>%\n        print()\n      \n      # add exercise thresholds from the Shiny manually inputted table\n      test_summary <-\n        add_threshold_zone(\n          threshold_zone_info = threshold_info,\n          test_summary = test_summary\n        ) %>%\n        print()\n      \n      # add exercise zones from the Shiny manually inputted table\n      test_summary <-\n        add_threshold_zone(\n          threshold_zone_info = zone_info,\n          test_summary = test_summary\n        ) %>%\n        print()\n      \n      # Delete the rounded 'Time' column and mutate a minute decimal time column in the avg_stage_data df\n      avg_stage_data <- \n        fix_time(\n          avg_stage_data\n        ) %>%\n        print()\n      \n      # Delete the rounded 'Time' column and mutate a minute decimal time column in the parvo_eg_data df\n      parvo_data$parvo_eg_data <-\n        fix_time(\n          parvo_data$parvo_eg_data\n        ) %>%\n        print()\n      \n      # Delete any columns consisting entirely of NA values. Used to remove lactate, RPE, thresholds, or zones if not inputted\n      avg_stage_data <-\n        remove_empty_columns(\n          avg_stage_data\n        ) %>%\n        print()\n      \n      # Delete any columns consisting entirely of NA values. Used to remove lactate, RPE, thresholds, or zones if not inputted\n      parvo_data$parvo_eg_data <-\n        remove_empty_columns(\n          parvo_data$parvo_eg_data\n        ) %>%\n        print()\n      \n      incProgress(0.9, detail = \"Making tables pretty ...\")\n      \n      # Render the rhandsontable for test_summary\n      output$test_summary_table <- renderRHandsontable({\n        rhandsontable(test_summary, rowHeaders = NULL) %>%\n          hot_col(col = \"Test_Date\", dateFormat = \"YYYY/MM/DD\", type = \"date\")\n      })\n      \n      # Excel download function for test_summary\n      output$download_step_test_summary_data_excel <- downloadHandler(\n        filename = function() {\n          paste(\"test_summary.xlsx\")\n        },\n        content = function(file) {\n          writexl::write_xlsx(reactive_test_summary(), path = file, col_names = TRUE, format_headers = FALSE)\n        }\n      )\n      \n      # CSV download function for test_summary\n      output$download_step_test_summary_data_csv <- downloadHandler(\n        filename = function() {\n          paste(\"test_summary.csv\")\n        },\n        content = function(file) {\n          readr::write_csv(reactive_test_summary(), file, col_names = TRUE)\n        }\n      )\n      \n      # Render the rhandsontable for avg_stage_data\n      output$avg_stage_data_table <- renderRHandsontable({\n        rhandsontable(avg_stage_data, rowHeaders = NULL)\n      }\n      )\n      \n      # Excel download function for avg_stage_data\n      output$download_step_avg_stage_data_excel <- downloadHandler(\n        filename = function() {\n          paste(\"avg_stage_data.xlsx\")\n        },\n        content = function(file) {\n          writexl::write_xlsx(reactive_avg_stage_data(), path = file, col_names = TRUE, format_headers = FALSE)\n        }\n      )\n      \n      # CSV download function for avg_stage_data\n      output$download_step_avg_stage_data_csv <- downloadHandler(\n        filename = function() {\n          paste(\"avg_stage_data.csv\")\n        },\n        content = function(file) {\n          readr::write_csv(reactive_avg_stage_data(), file, col_names = TRUE)\n        }\n      )\n      \n      # Render the rhandsontable for parvo_eg_data\n      output$parvo_eg_data_table <- renderRHandsontable({\n        rhandsontable(parvo_data$parvo_eg_data, rowHeaders = NULL)\n      }\n      )\n      \n      # Excel download function for parvo_eg_data\n      output$download_step_parvo_eg_data_excel <- downloadHandler(\n        filename = function() {\n          paste(\"parvo_eg_data.xlsx\")\n        },\n        content = function(file) {\n          writexl::write_xlsx(reactive_parvo_eg_data(), path = file, col_names = TRUE, format_headers = FALSE)\n        }\n      )\n      \n      # CSV download function for parvo_eg_data\n      output$download_step_parvo_eg_data_csv <- downloadHandler(\n        filename = function() {\n          paste(\"parvo_eg_data.csv\")\n        },\n        content = function(file) {\n          readr::write_csv(reactive_parvo_eg_data(), file, col_names = TRUE)\n        }\n      )\n      \n      # Updates the x- and y-variables of the plots\n      reactive_avg_stage_data_graphing(avg_stage_data)\n      \n      output$avg_stage_x_var_ui <- renderUI({\n        req(reactive_avg_stage_data_graphing())\n        selectInput(\"avg_stage_x_var\", \"Avg Stage X-axis variable:\", choices = names(reactive_avg_stage_data_graphing()), selected = \"Time_m\")\n      })\n      \n      output$avg_stage_y_var_ui <- renderUI({\n        req(reactive_avg_stage_data_graphing())\n        selectInput(\"avg_stage_y_var\", \"Avg Stage Y-axis variable:\", choices = names(reactive_avg_stage_data_graphing()), selected = \"VO2\")\n      })\n      \n      reactive_parvo_data_graphing(parvo_data)\n      \n      output$parvo_data_x_var_ui <- renderUI({\n        req(reactive_parvo_data_graphing())\n        selectInput(\"parvo_data_x_var\", \"Parvo Data X-axis variable:\", choices = names(reactive_parvo_data_graphing()$parvo_eg_data), selected = \"Time_m\")\n      })\n      \n      output$parvo_data_y_var_ui <- renderUI({\n        req(reactive_parvo_data_graphing())\n        selectInput(\"parvo_data_y_var\", \"Parvo Data Y-axis variable:\", choices = names(reactive_parvo_data_graphing()$parvo_eg_data), selected = \"VO2\")\n      })\n      \n      # Sweet Alert processing completion indicator\n      show_alert(\n        title = \"Success!\",\n        text = \"Processing Complete\",\n        type = \"success\",\n        btn_labels = \"Ok\"\n      )\n      \n    })\n  })\n  \n  # Code to render plots\n  output$avg_stage_plot <- renderPlotly({\n    req(reactive_avg_stage_data_graphing()) \n    \n    plot_ly(data = reactive_avg_stage_data_graphing(), x = ~get(input$avg_stage_x_var), y = ~get(input$avg_stage_y_var), \n            type = 'scatter', mode = 'markers') %>%\n      layout(title = 'Avg Stage Data Interactive Plot', \n             xaxis = list(title = input$avg_stage_x_var), yaxis = list(title = input$avg_stage_y_var))\n  })\n  \n  output$parvo_eg_plot <- renderPlotly({\n    req(reactive_parvo_data_graphing()) \n    parvo_eg_data <- reactive_parvo_data_graphing()$parvo_eg_data\n    \n    plot_ly(data = parvo_eg_data, x = ~get(input$parvo_data_x_var), y = ~get(input$parvo_data_y_var), \n            type = 'scatter', mode = 'markers') %>%\n      layout(title = 'Parvo Data Interactive Plot', \n             xaxis = list(title = input$parvo_data_x_var), yaxis = list(title = input$parvo_data_y_var))\n  })\n  \n}\n\n### RUN THE SHINY APP ========================================\n\nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"assign_intensity.R","content":"# Add \"Speed\", \"Protocol\", and \"Stage\" columns\nassign_intensity <- function(\n    data, protocol_1_start, protocol_1_increase, protocol_1_length,\n    use_baseline = FALSE, baseline_length = 0, baseline_intensity = 0,\n    use_protocol_2 = FALSE, time_of_change = 0, protocol_2_start = 0, protocol_2_increase = 0, protocol_2_length = 0,\n    use_break = FALSE, break_length = 0, break_speed = 0) {\n  \n  # adjust protocol_1_length so it either includes or doesn't include break_length, and also + 0.1 to ensure calculations do not exclude any required time period.\n  adjusted_protocol_1_length <- ifelse(use_break, protocol_1_length + break_length + 0.1, protocol_1_length + 0.1)\n  \n  # adjust time_of_change (when protocol_1 transitions to protocol_2) so that it only includes the first row after the time_of_change \n  adjusted_time_of_change <- time_of_change + 0.1\n  \n  if (use_baseline) {\n    adjusted_time_of_change <- adjusted_time_of_change + baseline_length\n  }\n  \n  # assign \"Speed\" column, with toggles for baseline, breaks, and change in step parameters\n  data <- data %>%\n    mutate(Speed = case_when(\n      use_baseline & Time <= baseline_length ~ baseline_intensity,\n      !use_protocol_2 | (use_protocol_2 & Time <= adjusted_time_of_change) ~ protocol_1_start + protocol_1_increase * ((Time - ifelse(use_baseline, baseline_length, 0)) %/% adjusted_protocol_1_length),\n      use_protocol_2 & Time > adjusted_time_of_change ~ protocol_2_start + protocol_2_increase * ((Time - adjusted_time_of_change) %/% protocol_2_length)\n    )) %>%\n    \n    # assign \"Protocol\" column, with toggles for baseline and change in step parameters\n    mutate(Protocol = case_when(\n      !(use_baseline | use_protocol_2) ~ \"protocol_1\",\n      use_baseline & !use_protocol_2 ~ ifelse(Time <= baseline_length, \"baseline\", \"protocol_1\"),\n      !use_baseline & use_protocol_2 ~ ifelse(Time > adjusted_time_of_change, \"protocol_2\", \"protocol_1\"),\n      use_baseline & use_protocol_2 ~ case_when(\n        Time <= baseline_length ~ \"baseline\",\n        Time <= adjusted_time_of_change ~ \"protocol_1\",\n        TRUE ~ \"protocol_2\"\n      )\n    )) %>%\n    \n    # assign \"Stage\" column based on rank, with - 1 to make sure it always starts at \"Stage_0\"\n    mutate(Stage = paste0(\"Stage_\", dense_rank(Speed) - 1))\n  \n  # adjust \"Speed\" column based on whether there are breaks\n  if (use_break) {\n    data <- data %>%\n      group_by(Stage) %>%\n      mutate(max_time = max(Time),\n             total_stage_time = max_time - min(Time) + mean(diff(Time)),\n             Speed = if_else((Protocol == \"protocol_1\") & (total_stage_time == adjusted_protocol_1_length - 0.1) & (Time > (max_time - break_length)), break_speed, Speed)) %>%\n      ungroup() %>%\n      select(-max_time, -total_stage_time)\n  }\n  \n  # adjust \"Protocol\" column so it starts at \"Stage_1\" if no baseline\n  if (data$Protocol[1] == \"protocol_1\") {\n    data <- data %>%\n      mutate(Stage = str_replace(Stage, \"(\\\\d+)$\", function(x) as.character(as.numeric(x) + 1)))\n  }\n  \n  # adjust \"Protocol\" column so all \"Stage_0\" are replaced with \"baseline\"\n  data <- data %>%\n    mutate(Stage = str_replace_all(Stage, \"Stage_0\", \"baseline\"))\n  \n  # add in min/km and m:ss, and rename Speed to Speed_kph\n  data <- data %>%\n    mutate(Speed_minkm_dec = if_else(Speed == 0, NA_real_, 60 / Speed),\n           Speed_minkm = if_else(\n             is.na(Speed_minkm_dec),\n             NA_character_,\n             sprintf(\"%d:%02d\", floor(Speed_minkm_dec), round((Speed_minkm_dec %% 1) * 60)))) %>%\n    rename(Speed_kph = Speed) %>%\n    relocate(Speed_minkm, Speed_minkm_dec, .after = Speed_kph)\n  \n  return(data)\n}\n","type":"text"},{"name":"parvo_process.R","content":"# Create parvo_data list with 2 df (parvo_metadata and parvo_eg_data)\n# Add some variables of interest\nparvo_process <- function(\n    parvo_data_raw,\n    col_names = c(\n      \"Time\", \"VO2\", \"VO2kg\", \"VCO2\",\n      \"RER\", \"RR\", \"VT\", \"VE\", \"VEVO2\", \"VEVCO2\",\n      \"FEO2\", \"FECO2\", \"HR\")){\n  \n  # Ensures the raw Parvo export file has all the variables of interest in the expired gas section\n  variables_of_interest_row <- which(grepl(\"---------\", parvo_data_raw[[1]]))\n  \n  required_variables <- c(\"TIME\", \"VO2\", \"VO2/kg\", \"VCO2\", \"RER\", \"RR\", \"Vt\", \"VE\", \"VE/\", \"VE/\", \"FEO2\", \"FECO2\", \"HR\")\n  if (variables_of_interest_row - 3 < 1 || !identical(required_variables, as.character(parvo_data_raw[variables_of_interest_row - 3, ]))) {\n    stop(\"Error: The required expired gas variables of interest are not found or do not match the expected order.\")\n  }\n  \n  # Ensures the first cell below \"---------\" contains a colon, which is used to assume time is exported in m:ss (and not in minute decimal format)\n  if (!grepl(\":\", parvo_data_raw[variables_of_interest_row + 1, 1])) {\n    stop(\"Error: Please export the Time column in 'm:ss' format.\")\n  }\n  \n  parvo_eg_data <- parvo_data_raw %>%\n    # remove metadata details so you only have df if expired gas data\n    slice_tail(n = -which(grepl(\"---------\", parvo_data_raw[[1]]))) %>% \n    # rename columns from col_names input\n    rename_with(~ col_names) %>% \n    # remove footer (Max, Events, and Summary) details, starting with first NA row in Time column\n    slice(-(head(which(is.na(Time)),1):nrow(.))) %>%\n    # convert all but Time column to numeric\n    mutate(across(-Time, ~ as.numeric(.))) %>% \n    # hide warnings when reading mixed data types\n    suppressWarnings() %>%\n    # create new Time column in seconds\n    mutate(Time_mss = Time) %>%\n    relocate(Time_mss, .before = Time) %>%\n    mutate(Time = lubridate::period_to_seconds(lubridate::ms(Time, roll = TRUE))) %>%\n    \n    # filter erroneous data where VO2 or VT below empirical cutoff. will keep the row of data, but replaces all the data with NA\n    mutate(\n      across(-c(Time, matches(\"Time_mss\")), ~ case_when(\n        VO2 < 0.1 | VT < 0.1 ~ NA_real_,\n        TRUE ~ .)),\n    ) %>%\n    \n    # create columns with additional variables of interest\n    mutate(\n      # substrate oxidation in g/min (VO2 & VCO2 in L/min), from Peronnet & Massicotte, 1991\n      CHO_gmin = 4.585 * VCO2 - 3.226 * VO2,\n      FAT_gmin = 1.695 * VO2 - 1.701 * VCO2,\n      # Jeukendrup & Wallis, 2005 (50-75% Intensity)\n      # Double check with Trent if go with 9 and 4 kcal/g\n      CHO_kcalmin = CHO_gmin * 4,\n      FAT_kcalmin = FAT_gmin * 9,\n      Total_kcalmin = FAT_kcalmin + CHO_kcalmin,\n      Total_kcalhr = Total_kcalmin * 60,\n      # calculate O2eq in kJ/L & kcal/L, from Péronnet & Massicotte, 1991\n      O2_kJL = 16.8835 + 4.8353 * pmin(pmax(RER, 0.7036), 0.9961),\n      O2_kcalL = 4.0372 + 1.1563 * pmin(pmax(RER, 0.7036), 0.9961),\n      # Aerobic Work Expenditure in kJ/min (VO2 in L/min, O2kJ in kJ/L)\n      WE_kJmin = VO2 * O2_kJL,\n      # Aerobic Power in W = J/sec (VO2 in L/min, O2kJ in kJ/L)\n      P_Js = VO2 * O2_kJL * 1000/60,\n      # Aerobic Energy Expenditure in kcal/min (VO2 in L/min, O2kcal in kcal/L)\n      EE_kcalmin = VO2 * O2_kcalL\n    )\n  \n  # create df with test metadata\n  parvo_metadata <- \n    tibble(\n      Name = as.character(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Name\", .)))[[which(grepl(\"Name\", parvo_data_raw)) + 1]]),\n      Test_Date = as.character(paste(parvo_data_raw[2, 2], sprintf(\"%02d\", as.numeric(parvo_data_raw[2, 4])), sprintf(\"%02d\", as.numeric(parvo_data_raw[2, 6])), sep = \"/\")),\n      Test_Time = paste(paste(parvo_data_raw[2, 7:9], collapse = \"\"), parvo_data_raw[2, 10], sep = \":\"),\n      Age = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Age\", .)))[[which(grepl(\"Age\", parvo_data_raw)) + 1]]),\n      Sex = case_when(\n        grepl(\"F\", filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Sex\", .)))[[which(grepl(\"Sex\", parvo_data_raw)) + 1]]) ~ \"female\",\n        grepl(\"M\", filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Sex\", .)))[[which(grepl(\"Sex\", parvo_data_raw)) + 1]]) ~ \"male\"),\n      Height = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Height\", .)))[[which(grepl(\"Height\", parvo_data_raw)) + 3]]),\n      Weight = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Weight\", .)))[[which(grepl(\"Weight\", parvo_data_raw)) + 3]]),\n      BMI = round(Weight / (Height/100)^2 , 2),\n      Temperature = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Insp. temp\", .)))[[which(grepl(\"Insp. temp\", parvo_data_raw)) + 1]]),\n      RH = as.numeric(filter(parvo_data_raw, if_any(everything(), ~ grepl(\"Insp. humidity\", .)))[[which(grepl(\"Insp. humidity\", parvo_data_raw)) + 1]])\n    )\n  \n  return(list(parvo_eg_data = parvo_eg_data, parvo_metadata = parvo_metadata))\n}\n","type":"text"},{"name":"remove_post_test_rows.R","content":"# Remove all rows that exceed the end of the test\nremove_post_test_rows <- function(data,input_time,use_baseline,baseline_length) {\n  \n  # Adjust the input_time if there is a baseline stage\n  if (use_baseline) {\n    input_time <- input_time + baseline_length\n  }\n  \n  # Find the index of the maximum value where Time is less than or equal to input_time\n  closest_index <- which.max(data$Time[data$Time <= input_time])\n  \n  # Check if there's an exact match\n  if (any(data$Time == input_time)) {\n    # If an exact match is found, get its index\n    exact_match_index <- which(data$Time == input_time)[1]\n    # Keep rows up to and including the exact match\n    result_data <- data[1:exact_match_index, ]\n  } else {\n    # If no exact match, find the closest preceding time and include the first row after it\n    if (length(closest_index) == 0) {\n      # Handle case when all times are greater than input_time\n      result_data <- data\n    } else {\n      # Ensure we do not exceed the bounds of the dataframe\n      end_index <- min(closest_index + 1, nrow(data))\n      result_data <- data[1:end_index, ]\n    }\n  }\n  \n  return(result_data)\n}\n","type":"text"},{"name":"replace_with_closest_multiple.R","content":"# Round time to make it easier to work with\nreplace_with_closest_multiple <- function(data) {\n  # Creates a new column to \"store\" the original \"Time\" values\n  data <- data %>%\n    mutate(Time_s = Time, .before = Time)\n  \n  # Replace the values with rounded \"Time\" values\n  rounded_diff <- round(mean(diff(data$Time)))\n  data$Time <- round(data$Time / rounded_diff) * rounded_diff\n  return(data)\n}\n","type":"text"}]
